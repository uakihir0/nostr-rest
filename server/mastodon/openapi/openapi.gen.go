// Package mopenapi provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.13.0 DO NOT EDIT.
package mopenapi

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

const (
	NPubOrNSecScopes = "NPubOrNSec.Scopes"
)

// Defines values for FilterContext.
const (
	FilterContextAccount       FilterContext = "account"
	FilterContextHome          FilterContext = "home"
	FilterContextNotifications FilterContext = "notifications"
	FilterContextPublic        FilterContext = "public"
	FilterContextThread        FilterContext = "thread"
)

// Defines values for FilterFilterAction.
const (
	Hide FilterFilterAction = "hide"
	Warn FilterFilterAction = "warn"
)

// Defines values for MediaAttachmentType.
const (
	MediaAttachmentTypeAudio   MediaAttachmentType = "audio"
	MediaAttachmentTypeGif     MediaAttachmentType = "gif"
	MediaAttachmentTypeImage   MediaAttachmentType = "image"
	MediaAttachmentTypeUnknown MediaAttachmentType = "unknown"
	MediaAttachmentTypeVideo   MediaAttachmentType = "video"
)

// Defines values for PreviewCardType.
const (
	PreviewCardTypeLink  PreviewCardType = "link"
	PreviewCardTypePhoto PreviewCardType = "photo"
	PreviewCardTypeRich  PreviewCardType = "rich"
	PreviewCardTypeVideo PreviewCardType = "video"
)

// Defines values for SourcePrivacy.
const (
	SourcePrivacyDirect   SourcePrivacy = "direct"
	SourcePrivacyPrivate  SourcePrivacy = "private"
	SourcePrivacyPublic   SourcePrivacy = "public"
	SourcePrivacyUnlisted SourcePrivacy = "unlisted"
)

// Defines values for StatusVisibility.
const (
	StatusVisibilityDirect   StatusVisibility = "direct"
	StatusVisibilityPrivate  StatusVisibility = "private"
	StatusVisibilityPublic   StatusVisibility = "public"
	StatusVisibilityUnlisted StatusVisibility = "unlisted"
)

// Defines values for StatusOrignVisibility.
const (
	StatusOrignVisibilityDirect   StatusOrignVisibility = "direct"
	StatusOrignVisibilityPrivate  StatusOrignVisibility = "private"
	StatusOrignVisibilityPublic   StatusOrignVisibility = "public"
	StatusOrignVisibilityUnlisted StatusOrignVisibility = "unlisted"
)

// Defines values for StatusReblogVisibility.
const (
	Direct   StatusReblogVisibility = "direct"
	Private  StatusReblogVisibility = "private"
	Public   StatusReblogVisibility = "public"
	Unlisted StatusReblogVisibility = "unlisted"
)

// Account defines model for Account.
type Account struct {
	// Acct The Webfinger account URI. Equal to username for local users, or username@domain for remote users.
	Acct string `json:"acct"`

	// Avatar An image icon that is shown next to statuses and in the profile. (URL)
	Avatar string `json:"avatar"`

	// AvatarStatic A static version of the avatar. Equal to avatar if its value is a static image; different if avatar is an animated GIF.
	AvatarStatic string `json:"avatar_static"`

	// Bot Indicates that the account may perform automated actions, may not be monitored, or identifies
	Bot bool `json:"bot"`

	// CreatedAt When the account was created. (ISO 8601)
	CreatedAt string `json:"created_at"`

	// Discoverable Whether the account has opted into discovery features such as the profile directory.
	Discoverable *bool `json:"discoverable"`

	// DisplayName The profile’s display name.
	DisplayName string `json:"display_name"`

	// Emojis Custom emoji entities to be used when rendering the profile.
	Emojis []CustomEmoji `json:"emojis"`

	// Fields Custom emoji entities to be used when rendering the profile.
	Fields []Field `json:"fields"`

	// FollowersCount The reported followers of this profile.
	FollowersCount int `json:"followers_count"`

	// FollowingCount The reported follows of this profile.
	FollowingCount int `json:"following_count"`

	// Group Indicates that the account represents a Group actor.
	Group bool `json:"group"`

	// Header An image banner that is shown above the profile and in profile cards.
	Header string `json:"header"`

	// HeaderStatic A static version of the header. Equal to header if its value is a static image; different if header is an animated GIF.
	HeaderStatic string `json:"header_static"`

	// Id The account id.
	Id string `json:"id"`

	// LastStatusAt When the most recent status was posted. (ISO 8601)
	LastStatusAt *string `json:"last_status_at"`

	// Limited An extra attribute returned only when an account is silenced. If true, indicates that the account should be hidden behind a warning screen.
	Limited *bool `json:"limited,omitempty"`

	// Locked Whether the account manually approves follow requests.
	Locked bool `json:"locked"`

	// Moved Indicates that the profile is currently inactive and that its user has moved to a new account.
	Moved *bool `json:"moved"`

	// Noindex Whether the local user has opted out of being indexed by search engines.
	Noindex *bool `json:"noindex"`

	// Note The profile’s bio or description. (HTML)
	Note string `json:"note"`

	// StatusesCount How many statuses are attached to this account.
	StatusesCount int `json:"statuses_count"`

	// Suspended An extra attribute returned only when an account is suspended.
	Suspended *bool `json:"suspended,omitempty"`

	// Url The location of the user’s profile page.
	Url string `json:"url"`

	// Username The username of the account, not including domain.
	Username string `json:"username"`
}

// Application defines model for Application.
type Application struct {
	Name    *string `json:"name"`
	Website *string `json:"website"`
}

// CredentialAccount defines model for CredentialAccount.
type CredentialAccount struct {
	// Acct The Webfinger account URI. Equal to username for local users, or username@domain for remote users.
	Acct string `json:"acct"`

	// Avatar An image icon that is shown next to statuses and in the profile. (URL)
	Avatar string `json:"avatar"`

	// AvatarStatic A static version of the avatar. Equal to avatar if its value is a static image; different if avatar is an animated GIF.
	AvatarStatic string `json:"avatar_static"`

	// Bot Indicates that the account may perform automated actions, may not be monitored, or identifies
	Bot bool `json:"bot"`

	// CreatedAt When the account was created. (ISO 8601)
	CreatedAt string `json:"created_at"`

	// Discoverable Whether the account has opted into discovery features such as the profile directory.
	Discoverable *bool `json:"discoverable"`

	// DisplayName The profile’s display name.
	DisplayName string `json:"display_name"`

	// Emojis Custom emoji entities to be used when rendering the profile.
	Emojis []CustomEmoji `json:"emojis"`

	// Fields Custom emoji entities to be used when rendering the profile.
	Fields []Field `json:"fields"`

	// FollowersCount The reported followers of this profile.
	FollowersCount int `json:"followers_count"`

	// FollowingCount The reported follows of this profile.
	FollowingCount int `json:"following_count"`

	// Group Indicates that the account represents a Group actor.
	Group bool `json:"group"`

	// Header An image banner that is shown above the profile and in profile cards.
	Header string `json:"header"`

	// HeaderStatic A static version of the header. Equal to header if its value is a static image; different if header is an animated GIF.
	HeaderStatic string `json:"header_static"`

	// Id The account id.
	Id string `json:"id"`

	// LastStatusAt When the most recent status was posted. (ISO 8601)
	LastStatusAt *string `json:"last_status_at"`

	// Limited An extra attribute returned only when an account is silenced. If true, indicates that the account should be hidden behind a warning screen.
	Limited *bool `json:"limited,omitempty"`

	// Locked Whether the account manually approves follow requests.
	Locked bool `json:"locked"`

	// Moved Indicates that the profile is currently inactive and that its user has moved to a new account.
	Moved *bool `json:"moved"`

	// Noindex Whether the local user has opted out of being indexed by search engines.
	Noindex *bool `json:"noindex"`

	// Note The profile’s bio or description. (HTML)
	Note   string `json:"note"`
	Role   Role   `json:"role"`
	Source Source `json:"source"`

	// StatusesCount How many statuses are attached to this account.
	StatusesCount int `json:"statuses_count"`

	// Suspended An extra attribute returned only when an account is suspended.
	Suspended *bool `json:"suspended,omitempty"`

	// Url The location of the user’s profile page.
	Url string `json:"url"`

	// Username The username of the account, not including domain.
	Username string `json:"username"`
}

// CustomEmoji defines model for CustomEmoji.
type CustomEmoji struct {
	// Category Used for sorting custom emoji in the picker.
	Category string `json:"category"`

	// Shortcode The name of the custom emoji.
	Shortcode string `json:"shortcode"`

	// StaticUrl A link to a static copy of the custom emoji.
	StaticUrl string `json:"static_url"`

	// Url A link to the custom emoji.
	Url string `json:"url"`

	// VisibleInPicker Whether this Emoji should be visible in the picker or unlisted.
	VisibleInPicker bool `json:"visible_in_picker"`
}

// Field defines model for Field.
type Field struct {
	// Name The key of a given field’s key-value pair.
	Name string `json:"name"`

	// Value The value associated with the name key.
	Value string `json:"value"`

	// VerifiedAt Timestamp of when the server verified a URL value for a rel=“me” link.
	VerifiedAt *string `json:"verified_at"`
}

// Filter Represents a user-defined filter for determining which statuses should not be shown to the user.
type Filter struct {
	// Context The contexts in which the filter should be applied.
	Context []FilterContext `json:"context"`

	// ExpiresAt When the filter should no longer be applied.
	ExpiresAt *string `json:"expires_at"`

	// FilterAction The action to be taken when a status matches this filter.
	FilterAction FilterFilterAction `json:"filter_action"`

	// Id The ID of the Filter in the database.
	Id string `json:"id"`

	// Keywords The keywords grouped under this filter.
	Keywords []FilterKeyword `json:"keywords"`

	// Statuses The statuses grouped under this filter.
	Statuses []FilterStatus `json:"statuses"`

	// Title A title given by the user to name the filter.
	Title string `json:"title"`
}

// FilterContext defines model for Filter.Context.
type FilterContext string

// FilterFilterAction The action to be taken when a status matches this filter.
type FilterFilterAction string

// FilterKeyword Represents a keyword that, if matched, should cause the filter action to be taken.
type FilterKeyword struct {
	// Id The ID of the FilterKeyword in the database.
	Id string `json:"id"`

	// Keyword The phrase to be matched against.
	Keyword string `json:"keyword"`

	// WholeWord Should the filter consider word boundaries? See implementation guidelines for filters.
	WholeWord bool `json:"whole_word"`
}

// FilterResult Represents a filter whose keywords matched a given status.
type FilterResult struct {
	// Filter Represents a user-defined filter for determining which statuses should not be shown to the user.
	Filter Filter `json:"filter"`

	// KeywordMatches The keyword within the filter that was matched.
	KeywordMatches *[]string `json:"keyword_matches"`

	// StatusMatches The status ID within the filter that was matched.
	StatusMatches *[]string `json:"status_matches"`
}

// FilterStatus Represents a status ID that, if matched, should cause the filter action to be taken.
type FilterStatus struct {
	// Id The ID of the FilterStatus in the database.
	Id string `json:"id"`

	// StatusId The ID of the Status that will be filtered.
	StatusId string `json:"status_id"`
}

// MediaAttachment defines model for MediaAttachment.
type MediaAttachment struct {
	// Blurhash A hash computed by the BlurHash algorithm, for generating colorful preview thumbnails when media has not been downloaded yet.
	Blurhash string `json:"blurhash"`

	// Description Alternate text that describes what is in the media attachment, to be used for the visually impaired or when media attachments do not load.
	Description string `json:"description"`

	// Id The ID of the attachment in the database.
	Id   string         `json:"id"`
	Meta MediaImegeMeta `json:"meta"`

	// PreviewUrl The location of a scaled-down preview of the attachment.
	PreviewUrl string `json:"preview_url"`

	// RemoteUrl The location of the full-size original attachment on the remote website.
	RemoteUrl *string `json:"remote_url"`

	// Type The type of the attachment.
	Type MediaAttachmentType `json:"type"`

	// Url The location of the original full-size attachment.
	Url string `json:"url"`
}

// MediaAttachmentType The type of the attachment.
type MediaAttachmentType string

// MediaImageForcus defines model for MediaImageForcus.
type MediaImageForcus struct {
	X *float32 `json:"x,omitempty"`
	Y *float32 `json:"y,omitempty"`
}

// MediaImageSize defines model for MediaImageSize.
type MediaImageSize struct {
	Aspect *float32 `json:"aspect,omitempty"`
	Height *int     `json:"height,omitempty"`
	Size   *string  `json:"size,omitempty"`
	Width  *int     `json:"width,omitempty"`
}

// MediaImegeMeta defines model for MediaImegeMeta.
type MediaImegeMeta struct {
	Focus    *MediaImageForcus `json:"focus,omitempty"`
	Original *MediaImageSize   `json:"original,omitempty"`
	Small    *MediaImageSize   `json:"small,omitempty"`
}

// Poll Represents a poll attached to a status.
type Poll struct {
	// Emojis Custom emoji to be used for rendering poll options.
	Emojis []CustomEmoji `json:"emojis"`

	// Expired Is the poll currently expired?
	Expired bool `json:"expired"`

	// ExpiresAt When the poll ends.
	ExpiresAt *string `json:"expires_at"`

	// Id The ID of the poll in the database.
	Id string `json:"id"`

	// Multiple Does the poll allow multiple-choice answers?
	Multiple bool `json:"multiple"`

	// Options Possible answers for the poll.
	Options []PollOption `json:"options"`

	// OwnVotes When called with a user token, which options has the authorized user chosen? Contains an array of index values for options.
	OwnVotes *[]int `json:"own_votes,omitempty"`

	// Voted When called with a user token, has the authorized user voted?
	Voted *bool `json:"voted,omitempty"`

	// VotersCount How many unique accounts have voted on a multiple-choice poll.
	VotersCount *int `json:"voters_count"`

	// VotesCount How many votes have been received.
	VotesCount int `json:"votes_count"`
}

// PollOption defines model for PollOption.
type PollOption struct {
	// Title The text value of the poll option.
	Title string `json:"title"`

	// VotesCount The total number of received votes for this option.
	VotesCount *int `json:"votes_count"`
}

// PreviewCard Represents a rich preview card that is generated using OpenGraph tags from a URL.
type PreviewCard struct {
	// AuthorName The author of the original resource.
	AuthorName string `json:"author_name"`

	// AuthorUrl A link to the author of the original resource.
	AuthorUrl string `json:"author_url"`

	// Blurhash A hash computed by the BlurHash algorithm, for generating colorful preview thumbnails when media has not been downloaded yet.
	Blurhash *string `json:"blurhash"`

	// Description Description of preview.
	Description string `json:"description"`

	// EmbedUrl Used for photo embeds, instead of custom html.
	EmbedUrl string `json:"embed_url"`

	// Height Height of preview, in pixels.
	Height int `json:"height"`

	// Html HTML to be used for generating the preview card.
	Html string `json:"html"`

	// Image Preview thumbnail.
	Image *string `json:"image"`

	// ProviderName The provider of the original resource.
	ProviderName string `json:"provider_name"`

	// ProviderUrl A link to the provider of the original resource.
	ProviderUrl string `json:"provider_url"`

	// Title Title of linked resource.
	Title string `json:"title"`

	// Type The type of the preview card.
	Type PreviewCardType `json:"type"`

	// Url Location of linked resource.
	Url string `json:"url"`

	// Width Width of preview, in pixels.
	Width int `json:"width"`
}

// PreviewCardType The type of the preview card.
type PreviewCardType string

// Role defines model for Role.
type Role struct {
	// Color The hex code assigned to this role. If no hex code is assigned, the string will be empty.
	Color string `json:"color"`

	// Highlighted  Whether the role is publicly visible as a badge on user profiles.
	Highlighted bool `json:"highlighted"`

	// Id The ID of the Role in the database.
	Id int `json:"id"`

	// Name The name of the role.
	Name string `json:"name"`

	// Permissions A bitmask that represents the sum of all permissions granted to the role.
	Permissions int `json:"permissions"`
}

// Source defines model for Source.
type Source struct {
	// Fields Metadata about the account.
	Fields []Field `json:"fields"`

	// FollowRequestsCount The number of pending follow requests.
	FollowRequestsCount int `json:"follow_requests_count"`

	// Language The default posting language for new statuses. (ISO 639-1 language two-letter code) or empty string.
	Language string `json:"language"`

	// Note Profile bio, in plain-text instead of in HTML.
	Note string `json:"note"`

	// Privacy The default post privacy to be used for new statuses.
	Privacy SourcePrivacy `json:"privacy"`

	// Sensitive Whether new statuses should be marked sensitive by default.
	Sensitive bool `json:"sensitive"`
}

// SourcePrivacy The default post privacy to be used for new statuses.
type SourcePrivacy string

// Status defines model for Status.
type Status struct {
	Account     Account      `json:"account"`
	Application *Application `json:"application,omitempty"`

	// Bookmarked If the current token has an authorized user: Have you bookmarked this status?
	Bookmarked *bool `json:"bookmarked,omitempty"`

	// Card Represents a rich preview card that is generated using OpenGraph tags from a URL.
	Card PreviewCard `json:"card"`

	// Content HTML-encoded status content.
	Content string `json:"content"`

	// CreatedAt The date when this status was created.
	CreatedAt string `json:"created_at"`

	// EditedAt Timestamp of when the status was last edited.
	EditedAt *string `json:"edited_at"`

	// Emojis Custom emoji to be used when rendering status content.
	Emojis []CustomEmoji `json:"emojis"`

	// Favourited If the current token has an authorized user: Have you favourited this status?
	Favourited *bool `json:"favourited,omitempty"`

	// FavouritesCount How many favourites this status has received.
	FavouritesCount int `json:"favourites_count"`

	// Filtered If the current token has an authorized user: The filter and keywords that matched this status.
	Filtered *[]FilterResult `json:"filtered,omitempty"`

	// Id ID of the status in the database.
	Id string `json:"id"`

	// InReplyToAccountId ID of the account that authored the status being replied to.
	InReplyToAccountId *string `json:"in_reply_to_account_id"`

	// InReplyToId ID of the status being replied to.
	InReplyToId *string `json:"in_reply_to_id"`

	// Language Primary language of this status.
	Language *string `json:"language"`

	// MediaAttachments Media that is attached to this status.
	MediaAttachments []MediaAttachment `json:"media_attachments"`

	// Mentions Mentions of users within the status content.
	Mentions []StatusMention `json:"mentions"`

	// Muted If the current token has an authorized user: Have you muted notifications for this status’s conversation?
	Muted *bool `json:"muted,omitempty"`

	// Pinned If the current token has an authorized user: Have you pinned this status? Only appears if the status is pinnable.
	Pinned *bool `json:"pinned,omitempty"`

	// Poll Represents a poll attached to a status.
	Poll Poll `json:"poll"`

	// Reblog The status being reblogged.
	Reblog Status_Reblog `json:"reblog"`

	// Reblogged If the current token has an authorized user: Have you boosted this status?
	Reblogged *bool `json:"reblogged,omitempty"`

	// ReblogsCount How many boosts this status has received.
	ReblogsCount int `json:"reblogs_count"`

	// RepliesCount How many replies this status has received.
	RepliesCount int `json:"replies_count"`

	// Sensitive Is this status marked as sensitive content?
	Sensitive bool `json:"sensitive"`

	// SpoilerText Subject or summary line, below which status content is collapsed until expanded.
	SpoilerText string `json:"spoiler_text"`

	// Tags Hashtags used within the status content.
	Tags []StatusTag `json:"tags"`

	// Text Plain-text source of a status. Returned instead of content when status is deleted, so the user may redraft from the source text without the client having to reverse-engineer the original text from the HTML content.
	Text *string `json:"text"`

	// Uri URI of the status used for federation.
	Uri string `json:"uri"`

	// Url A link to the status’s HTML representation.
	Url *string `json:"url"`

	// Visibility Visibility of this status.
	Visibility StatusVisibility `json:"visibility"`
}

// StatusReblog1 defines model for .
type StatusReblog1 = map[string]interface{}

// Status_Reblog The status being reblogged.
type Status_Reblog struct {
	union json.RawMessage
}

// StatusVisibility Visibility of this status.
type StatusVisibility string

// StatusMention defines model for StatusMention.
type StatusMention struct {
	// Acct The webfinger acct: URI of the mentioned user. Equivalent to username for local users, or username@domain for remote users.
	Acct string `json:"acct"`

	// Id The account ID of the mentioned user.
	Id string `json:"id"`

	// Url The location of the mentioned user’s profile.
	Url string `json:"url"`

	// Username The username of the mentioned user.
	Username string `json:"username"`
}

// StatusOrign Represents a status posted by an account.
type StatusOrign struct {
	Account     Account      `json:"account"`
	Application *Application `json:"application,omitempty"`

	// Bookmarked If the current token has an authorized user: Have you bookmarked this status?
	Bookmarked *bool `json:"bookmarked,omitempty"`

	// Card Represents a rich preview card that is generated using OpenGraph tags from a URL.
	Card PreviewCard `json:"card"`

	// Content HTML-encoded status content.
	Content string `json:"content"`

	// CreatedAt The date when this status was created.
	CreatedAt string `json:"created_at"`

	// EditedAt Timestamp of when the status was last edited.
	EditedAt *string `json:"edited_at"`

	// Emojis Custom emoji to be used when rendering status content.
	Emojis []CustomEmoji `json:"emojis"`

	// Favourited If the current token has an authorized user: Have you favourited this status?
	Favourited *bool `json:"favourited,omitempty"`

	// FavouritesCount How many favourites this status has received.
	FavouritesCount int `json:"favourites_count"`

	// Filtered If the current token has an authorized user: The filter and keywords that matched this status.
	Filtered *[]FilterResult `json:"filtered,omitempty"`

	// Id ID of the status in the database.
	Id string `json:"id"`

	// InReplyToAccountId ID of the account that authored the status being replied to.
	InReplyToAccountId *string `json:"in_reply_to_account_id"`

	// InReplyToId ID of the status being replied to.
	InReplyToId *string `json:"in_reply_to_id"`

	// Language Primary language of this status.
	Language *string `json:"language"`

	// MediaAttachments Media that is attached to this status.
	MediaAttachments []MediaAttachment `json:"media_attachments"`

	// Mentions Mentions of users within the status content.
	Mentions []StatusMention `json:"mentions"`

	// Muted If the current token has an authorized user: Have you muted notifications for this status’s conversation?
	Muted *bool `json:"muted,omitempty"`

	// Pinned If the current token has an authorized user: Have you pinned this status? Only appears if the status is pinnable.
	Pinned *bool `json:"pinned,omitempty"`

	// Poll Represents a poll attached to a status.
	Poll Poll `json:"poll"`

	// Reblogged If the current token has an authorized user: Have you boosted this status?
	Reblogged *bool `json:"reblogged,omitempty"`

	// ReblogsCount How many boosts this status has received.
	ReblogsCount int `json:"reblogs_count"`

	// RepliesCount How many replies this status has received.
	RepliesCount int `json:"replies_count"`

	// Sensitive Is this status marked as sensitive content?
	Sensitive bool `json:"sensitive"`

	// SpoilerText Subject or summary line, below which status content is collapsed until expanded.
	SpoilerText string `json:"spoiler_text"`

	// Tags Hashtags used within the status content.
	Tags []StatusTag `json:"tags"`

	// Text Plain-text source of a status. Returned instead of content when status is deleted, so the user may redraft from the source text without the client having to reverse-engineer the original text from the HTML content.
	Text *string `json:"text"`

	// Uri URI of the status used for federation.
	Uri string `json:"uri"`

	// Url A link to the status’s HTML representation.
	Url *string `json:"url"`

	// Visibility Visibility of this status.
	Visibility StatusOrignVisibility `json:"visibility"`
}

// StatusOrignVisibility Visibility of this status.
type StatusOrignVisibility string

// StatusReblog defines model for StatusReblog.
type StatusReblog struct {
	Account     Account      `json:"account"`
	Application *Application `json:"application,omitempty"`

	// Bookmarked If the current token has an authorized user: Have you bookmarked this status?
	Bookmarked *bool `json:"bookmarked,omitempty"`

	// Card Represents a rich preview card that is generated using OpenGraph tags from a URL.
	Card PreviewCard `json:"card"`

	// Content HTML-encoded status content.
	Content string `json:"content"`

	// CreatedAt The date when this status was created.
	CreatedAt string `json:"created_at"`

	// EditedAt Timestamp of when the status was last edited.
	EditedAt *string `json:"edited_at"`

	// Emojis Custom emoji to be used when rendering status content.
	Emojis []CustomEmoji `json:"emojis"`

	// Favourited If the current token has an authorized user: Have you favourited this status?
	Favourited *bool `json:"favourited,omitempty"`

	// FavouritesCount How many favourites this status has received.
	FavouritesCount int `json:"favourites_count"`

	// Filtered If the current token has an authorized user: The filter and keywords that matched this status.
	Filtered *[]FilterResult `json:"filtered,omitempty"`

	// Id ID of the status in the database.
	Id string `json:"id"`

	// InReplyToAccountId ID of the account that authored the status being replied to.
	InReplyToAccountId *string `json:"in_reply_to_account_id"`

	// InReplyToId ID of the status being replied to.
	InReplyToId *string `json:"in_reply_to_id"`

	// Language Primary language of this status.
	Language *string `json:"language"`

	// MediaAttachments Media that is attached to this status.
	MediaAttachments []MediaAttachment `json:"media_attachments"`

	// Mentions Mentions of users within the status content.
	Mentions []StatusMention `json:"mentions"`

	// Muted If the current token has an authorized user: Have you muted notifications for this status’s conversation?
	Muted *bool `json:"muted,omitempty"`

	// Pinned If the current token has an authorized user: Have you pinned this status? Only appears if the status is pinnable.
	Pinned *bool `json:"pinned,omitempty"`

	// Poll Represents a poll attached to a status.
	Poll   Poll                    `json:"poll"`
	Reblog *map[string]interface{} `json:"reblog"`

	// Reblogged If the current token has an authorized user: Have you boosted this status?
	Reblogged *bool `json:"reblogged,omitempty"`

	// ReblogsCount How many boosts this status has received.
	ReblogsCount int `json:"reblogs_count"`

	// RepliesCount How many replies this status has received.
	RepliesCount int `json:"replies_count"`

	// Sensitive Is this status marked as sensitive content?
	Sensitive bool `json:"sensitive"`

	// SpoilerText Subject or summary line, below which status content is collapsed until expanded.
	SpoilerText string `json:"spoiler_text"`

	// Tags Hashtags used within the status content.
	Tags []StatusTag `json:"tags"`

	// Text Plain-text source of a status. Returned instead of content when status is deleted, so the user may redraft from the source text without the client having to reverse-engineer the original text from the HTML content.
	Text *string `json:"text"`

	// Uri URI of the status used for federation.
	Uri string `json:"uri"`

	// Url A link to the status’s HTML representation.
	Url *string `json:"url"`

	// Visibility Visibility of this status.
	Visibility StatusReblogVisibility `json:"visibility"`
}

// StatusReblogVisibility Visibility of this status.
type StatusReblogVisibility string

// StatusTag defines model for StatusTag.
type StatusTag struct {
	// Name The value of the hashtag after the # sign.
	Name string `json:"name"`

	// Url A link to the hashtag on the instance.
	Url string `json:"url"`
}

// ExcludeReblogsQueryParam defines model for ExcludeReblogsQueryParam.
type ExcludeReblogsQueryParam = bool

// ExcludeRepliesQueryParam defines model for ExcludeRepliesQueryParam.
type ExcludeRepliesQueryParam = bool

// LimitQueryParam defines model for LimitQueryParam.
type LimitQueryParam = int

// MaxIdQueryParam defines model for MaxIdQueryParam.
type MaxIdQueryParam = string

// MinIdQueryParam defines model for MinIdQueryParam.
type MinIdQueryParam = string

// OnlyMediaQueryParam defines model for OnlyMediaQueryParam.
type OnlyMediaQueryParam = bool

// PinnedQueryParam defines model for PinnedQueryParam.
type PinnedQueryParam = bool

// SinceIdQueryParam defines model for SinceIdQueryParam.
type SinceIdQueryParam = string

// TaggedQueryParam defines model for TaggedQueryParam.
type TaggedQueryParam = string

// GetApiV1AccountsUidStatusesParams defines parameters for GetApiV1AccountsUidStatuses.
type GetApiV1AccountsUidStatusesParams struct {
	// MaxId Return results older than this ID
	MaxId *MaxIdQueryParam `form:"max_id,omitempty" json:"max_id,omitempty"`

	// SinceId Return results newer than this ID
	SinceId *SinceIdQueryParam `form:"since_id,omitempty" json:"since_id,omitempty"`

	// MinId Return results immediately newer than this ID
	MinId *MinIdQueryParam `form:"min_id,omitempty" json:"min_id,omitempty"`

	// Limit Maximum number of results to return. Defaults to 20 statuses. Max 40 statuses.
	Limit *LimitQueryParam `form:"limit,omitempty" json:"limit,omitempty"`

	// OnlyMedia Filter out statuses without attachments.
	OnlyMedia *OnlyMediaQueryParam `form:"only_media,omitempty" json:"only_media,omitempty"`

	// ExcludeReplies Filter out statuses in reply to a different account.
	ExcludeReplies *ExcludeRepliesQueryParam `form:"exclude_replies,omitempty" json:"exclude_replies,omitempty"`

	// ExcludeReblogs Filter out boosts from the response.
	ExcludeReblogs *ExcludeReblogsQueryParam `form:"exclude_reblogs,omitempty" json:"exclude_reblogs,omitempty"`

	// Pinned Filter for pinned statuses only.
	Pinned *PinnedQueryParam `form:"pinned,omitempty" json:"pinned,omitempty"`

	// Tagged Filter for statuses using a specific hashtag.
	Tagged *TaggedQueryParam `form:"tagged,omitempty" json:"tagged,omitempty"`
}

// AsStatusReblog returns the union data inside the Status_Reblog as a StatusReblog
func (t Status_Reblog) AsStatusReblog() (StatusReblog, error) {
	var body StatusReblog
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStatusReblog overwrites any union data inside the Status_Reblog as the provided StatusReblog
func (t *Status_Reblog) FromStatusReblog(v StatusReblog) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStatusReblog performs a merge with any union data inside the Status_Reblog, using the provided StatusReblog
func (t *Status_Reblog) MergeStatusReblog(v StatusReblog) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsStatusReblog1 returns the union data inside the Status_Reblog as a StatusReblog1
func (t Status_Reblog) AsStatusReblog1() (StatusReblog1, error) {
	var body StatusReblog1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStatusReblog1 overwrites any union data inside the Status_Reblog as the provided StatusReblog1
func (t *Status_Reblog) FromStatusReblog1(v StatusReblog1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStatusReblog1 performs a merge with any union data inside the Status_Reblog, using the provided StatusReblog1
func (t *Status_Reblog) MergeStatusReblog1(v StatusReblog1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t Status_Reblog) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Status_Reblog) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Verify account credentials
	// (GET /api/v1/accounts/verify_credentials)
	GetApiV1AccountsVerifyCredentials(ctx echo.Context) error
	// Get account
	// (GET /api/v1/accounts/{uid})
	GetApiV1AccountsUid(ctx echo.Context, uid string) error
	// Get account’s statuses
	// (GET /api/v1/accounts/{uid}/statuses)
	GetApiV1AccountsUidStatuses(ctx echo.Context, uid string, params GetApiV1AccountsUidStatusesParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// GetApiV1AccountsVerifyCredentials converts echo context to params.
func (w *ServerInterfaceWrapper) GetApiV1AccountsVerifyCredentials(ctx echo.Context) error {
	var err error

	ctx.Set(NPubOrNSecScopes, []string{})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApiV1AccountsVerifyCredentials(ctx)
	return err
}

// GetApiV1AccountsUid converts echo context to params.
func (w *ServerInterfaceWrapper) GetApiV1AccountsUid(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "uid" -------------
	var uid string

	err = runtime.BindStyledParameterWithLocation("simple", false, "uid", runtime.ParamLocationPath, ctx.Param("uid"), &uid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter uid: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApiV1AccountsUid(ctx, uid)
	return err
}

// GetApiV1AccountsUidStatuses converts echo context to params.
func (w *ServerInterfaceWrapper) GetApiV1AccountsUidStatuses(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "uid" -------------
	var uid string

	err = runtime.BindStyledParameterWithLocation("simple", false, "uid", runtime.ParamLocationPath, ctx.Param("uid"), &uid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter uid: %s", err))
	}

	ctx.Set(NPubOrNSecScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApiV1AccountsUidStatusesParams
	// ------------- Optional query parameter "max_id" -------------

	err = runtime.BindQueryParameter("form", true, false, "max_id", ctx.QueryParams(), &params.MaxId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max_id: %s", err))
	}

	// ------------- Optional query parameter "since_id" -------------

	err = runtime.BindQueryParameter("form", true, false, "since_id", ctx.QueryParams(), &params.SinceId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter since_id: %s", err))
	}

	// ------------- Optional query parameter "min_id" -------------

	err = runtime.BindQueryParameter("form", true, false, "min_id", ctx.QueryParams(), &params.MinId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min_id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "only_media" -------------

	err = runtime.BindQueryParameter("form", true, false, "only_media", ctx.QueryParams(), &params.OnlyMedia)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter only_media: %s", err))
	}

	// ------------- Optional query parameter "exclude_replies" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude_replies", ctx.QueryParams(), &params.ExcludeReplies)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude_replies: %s", err))
	}

	// ------------- Optional query parameter "exclude_reblogs" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude_reblogs", ctx.QueryParams(), &params.ExcludeReblogs)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude_reblogs: %s", err))
	}

	// ------------- Optional query parameter "pinned" -------------

	err = runtime.BindQueryParameter("form", true, false, "pinned", ctx.QueryParams(), &params.Pinned)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter pinned: %s", err))
	}

	// ------------- Optional query parameter "tagged" -------------

	err = runtime.BindQueryParameter("form", true, false, "tagged", ctx.QueryParams(), &params.Tagged)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tagged: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApiV1AccountsUidStatuses(ctx, uid, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/api/v1/accounts/verify_credentials", wrapper.GetApiV1AccountsVerifyCredentials)
	router.GET(baseURL+"/api/v1/accounts/:uid", wrapper.GetApiV1AccountsUid)
	router.GET(baseURL+"/api/v1/accounts/:uid/statuses", wrapper.GetApiV1AccountsUidStatuses)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"AAA=",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
