// Package mopenapi provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.14.0 DO NOT EDIT.
package mopenapi

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"github.com/oapi-codegen/runtime"
)

const (
	NPubOrNSecScopes = "NPubOrNSec.Scopes"
)

// Defines values for FilterContext.
const (
	FilterContextAccount       FilterContext = "account"
	FilterContextHome          FilterContext = "home"
	FilterContextNotifications FilterContext = "notifications"
	FilterContextPublic        FilterContext = "public"
	FilterContextThread        FilterContext = "thread"
)

// Defines values for FilterFilterAction.
const (
	Hide FilterFilterAction = "hide"
	Warn FilterFilterAction = "warn"
)

// Defines values for MediaAttachmentType.
const (
	MediaAttachmentTypeAudio   MediaAttachmentType = "audio"
	MediaAttachmentTypeGif     MediaAttachmentType = "gif"
	MediaAttachmentTypeImage   MediaAttachmentType = "image"
	MediaAttachmentTypeUnknown MediaAttachmentType = "unknown"
	MediaAttachmentTypeVideo   MediaAttachmentType = "video"
)

// Defines values for PreviewCardType.
const (
	PreviewCardTypeLink  PreviewCardType = "link"
	PreviewCardTypePhoto PreviewCardType = "photo"
	PreviewCardTypeRich  PreviewCardType = "rich"
	PreviewCardTypeVideo PreviewCardType = "video"
)

// Defines values for SourcePrivacy.
const (
	SourcePrivacyDirect   SourcePrivacy = "direct"
	SourcePrivacyPrivate  SourcePrivacy = "private"
	SourcePrivacyPublic   SourcePrivacy = "public"
	SourcePrivacyUnlisted SourcePrivacy = "unlisted"
)

// Defines values for StatusVisibility.
const (
	StatusVisibilityDirect   StatusVisibility = "direct"
	StatusVisibilityPrivate  StatusVisibility = "private"
	StatusVisibilityPublic   StatusVisibility = "public"
	StatusVisibilityUnlisted StatusVisibility = "unlisted"
)

// Defines values for StatusOrignVisibility.
const (
	StatusOrignVisibilityDirect   StatusOrignVisibility = "direct"
	StatusOrignVisibilityPrivate  StatusOrignVisibility = "private"
	StatusOrignVisibilityPublic   StatusOrignVisibility = "public"
	StatusOrignVisibilityUnlisted StatusOrignVisibility = "unlisted"
)

// Defines values for StatusReblogVisibility.
const (
	Direct   StatusReblogVisibility = "direct"
	Private  StatusReblogVisibility = "private"
	Public   StatusReblogVisibility = "public"
	Unlisted StatusReblogVisibility = "unlisted"
)

// Account defines model for Account.
type Account struct {
	// Acct The Webfinger account URI. Equal to username for local users, or username@domain for remote users.
	Acct string `json:"acct"`

	// Avatar An image icon that is shown next to statuses and in the profile. (URL)
	Avatar string `json:"avatar"`

	// AvatarStatic A static version of the avatar. Equal to avatar if its value is a static image; different if avatar is an animated GIF.
	AvatarStatic string `json:"avatar_static"`

	// Bot Indicates that the account may perform automated actions, may not be monitored, or identifies
	Bot bool `json:"bot"`

	// CreatedAt When the account was created. (ISO 8601)
	CreatedAt string `json:"created_at"`

	// Discoverable Whether the account has opted into discovery features such as the profile directory.
	Discoverable *bool `json:"discoverable"`

	// DisplayName The profile’s display name.
	DisplayName string `json:"display_name"`

	// Emojis Custom emoji entities to be used when rendering the profile.
	Emojis []CustomEmoji `json:"emojis"`

	// Fields Custom emoji entities to be used when rendering the profile.
	Fields []Field `json:"fields"`

	// FollowersCount The reported followers of this profile.
	FollowersCount int `json:"followers_count"`

	// FollowingCount The reported follows of this profile.
	FollowingCount int `json:"following_count"`

	// Group Indicates that the account represents a Group actor.
	Group bool `json:"group"`

	// Header An image banner that is shown above the profile and in profile cards.
	Header string `json:"header"`

	// HeaderStatic A static version of the header. Equal to header if its value is a static image; different if header is an animated GIF.
	HeaderStatic string `json:"header_static"`

	// Id The account id.
	Id string `json:"id"`

	// LastStatusAt When the most recent status was posted. (ISO 8601)
	LastStatusAt *string `json:"last_status_at"`

	// Limited An extra attribute returned only when an account is silenced. If true, indicates that the account should be hidden behind a warning screen.
	Limited *bool `json:"limited,omitempty"`

	// Locked Whether the account manually approves follow requests.
	Locked bool `json:"locked"`

	// Moved Indicates that the profile is currently inactive and that its user has moved to a new account.
	Moved *bool `json:"moved"`

	// Noindex Whether the local user has opted out of being indexed by search engines.
	Noindex *bool `json:"noindex"`

	// Note The profile’s bio or description. (HTML)
	Note string `json:"note"`

	// StatusesCount How many statuses are attached to this account.
	StatusesCount int `json:"statuses_count"`

	// Suspended An extra attribute returned only when an account is suspended.
	Suspended *bool `json:"suspended,omitempty"`

	// Url The location of the user’s profile page.
	Url string `json:"url"`

	// Username The username of the account, not including domain.
	Username string `json:"username"`
}

// Application defines model for Application.
type Application struct {
	Name    *string `json:"name"`
	Website *string `json:"website"`
}

// CredentialAccount defines model for CredentialAccount.
type CredentialAccount struct {
	// Acct The Webfinger account URI. Equal to username for local users, or username@domain for remote users.
	Acct string `json:"acct"`

	// Avatar An image icon that is shown next to statuses and in the profile. (URL)
	Avatar string `json:"avatar"`

	// AvatarStatic A static version of the avatar. Equal to avatar if its value is a static image; different if avatar is an animated GIF.
	AvatarStatic string `json:"avatar_static"`

	// Bot Indicates that the account may perform automated actions, may not be monitored, or identifies
	Bot bool `json:"bot"`

	// CreatedAt When the account was created. (ISO 8601)
	CreatedAt string `json:"created_at"`

	// Discoverable Whether the account has opted into discovery features such as the profile directory.
	Discoverable *bool `json:"discoverable"`

	// DisplayName The profile’s display name.
	DisplayName string `json:"display_name"`

	// Emojis Custom emoji entities to be used when rendering the profile.
	Emojis []CustomEmoji `json:"emojis"`

	// Fields Custom emoji entities to be used when rendering the profile.
	Fields []Field `json:"fields"`

	// FollowersCount The reported followers of this profile.
	FollowersCount int `json:"followers_count"`

	// FollowingCount The reported follows of this profile.
	FollowingCount int `json:"following_count"`

	// Group Indicates that the account represents a Group actor.
	Group bool `json:"group"`

	// Header An image banner that is shown above the profile and in profile cards.
	Header string `json:"header"`

	// HeaderStatic A static version of the header. Equal to header if its value is a static image; different if header is an animated GIF.
	HeaderStatic string `json:"header_static"`

	// Id The account id.
	Id string `json:"id"`

	// LastStatusAt When the most recent status was posted. (ISO 8601)
	LastStatusAt *string `json:"last_status_at"`

	// Limited An extra attribute returned only when an account is silenced. If true, indicates that the account should be hidden behind a warning screen.
	Limited *bool `json:"limited,omitempty"`

	// Locked Whether the account manually approves follow requests.
	Locked bool `json:"locked"`

	// Moved Indicates that the profile is currently inactive and that its user has moved to a new account.
	Moved *bool `json:"moved"`

	// Noindex Whether the local user has opted out of being indexed by search engines.
	Noindex *bool `json:"noindex"`

	// Note The profile’s bio or description. (HTML)
	Note   string `json:"note"`
	Role   Role   `json:"role"`
	Source Source `json:"source"`

	// StatusesCount How many statuses are attached to this account.
	StatusesCount int `json:"statuses_count"`

	// Suspended An extra attribute returned only when an account is suspended.
	Suspended *bool `json:"suspended,omitempty"`

	// Url The location of the user’s profile page.
	Url string `json:"url"`

	// Username The username of the account, not including domain.
	Username string `json:"username"`
}

// CustomEmoji defines model for CustomEmoji.
type CustomEmoji struct {
	// Category Used for sorting custom emoji in the picker.
	Category string `json:"category"`

	// Shortcode The name of the custom emoji.
	Shortcode string `json:"shortcode"`

	// StaticUrl A link to a static copy of the custom emoji.
	StaticUrl string `json:"static_url"`

	// Url A link to the custom emoji.
	Url string `json:"url"`

	// VisibleInPicker Whether this Emoji should be visible in the picker or unlisted.
	VisibleInPicker bool `json:"visible_in_picker"`
}

// Field defines model for Field.
type Field struct {
	// Name The key of a given field’s key-value pair.
	Name string `json:"name"`

	// Value The value associated with the name key.
	Value string `json:"value"`

	// VerifiedAt Timestamp of when the server verified a URL value for a rel=“me” link.
	VerifiedAt *string `json:"verified_at"`
}

// Filter Represents a user-defined filter for determining which statuses should not be shown to the user.
type Filter struct {
	// Context The contexts in which the filter should be applied.
	Context []FilterContext `json:"context"`

	// ExpiresAt When the filter should no longer be applied.
	ExpiresAt *string `json:"expires_at"`

	// FilterAction The action to be taken when a status matches this filter.
	FilterAction FilterFilterAction `json:"filter_action"`

	// Id The ID of the Filter in the database.
	Id string `json:"id"`

	// Keywords The keywords grouped under this filter.
	Keywords []FilterKeyword `json:"keywords"`

	// Statuses The statuses grouped under this filter.
	Statuses []FilterStatus `json:"statuses"`

	// Title A title given by the user to name the filter.
	Title string `json:"title"`
}

// FilterContext defines model for Filter.Context.
type FilterContext string

// FilterFilterAction The action to be taken when a status matches this filter.
type FilterFilterAction string

// FilterKeyword Represents a keyword that, if matched, should cause the filter action to be taken.
type FilterKeyword struct {
	// Id The ID of the FilterKeyword in the database.
	Id string `json:"id"`

	// Keyword The phrase to be matched against.
	Keyword string `json:"keyword"`

	// WholeWord Should the filter consider word boundaries? See implementation guidelines for filters.
	WholeWord bool `json:"whole_word"`
}

// FilterResult Represents a filter whose keywords matched a given status.
type FilterResult struct {
	// Filter Represents a user-defined filter for determining which statuses should not be shown to the user.
	Filter Filter `json:"filter"`

	// KeywordMatches The keyword within the filter that was matched.
	KeywordMatches *[]string `json:"keyword_matches"`

	// StatusMatches The status ID within the filter that was matched.
	StatusMatches *[]string `json:"status_matches"`
}

// FilterStatus Represents a status ID that, if matched, should cause the filter action to be taken.
type FilterStatus struct {
	// Id The ID of the FilterStatus in the database.
	Id string `json:"id"`

	// StatusId The ID of the Status that will be filtered.
	StatusId string `json:"status_id"`
}

// MediaAttachment defines model for MediaAttachment.
type MediaAttachment struct {
	// Blurhash A hash computed by the BlurHash algorithm, for generating colorful preview thumbnails when media has not been downloaded yet.
	Blurhash string `json:"blurhash"`

	// Description Alternate text that describes what is in the media attachment, to be used for the visually impaired or when media attachments do not load.
	Description string `json:"description"`

	// Id The ID of the attachment in the database.
	Id   string         `json:"id"`
	Meta MediaImegeMeta `json:"meta"`

	// PreviewUrl The location of a scaled-down preview of the attachment.
	PreviewUrl string `json:"preview_url"`

	// RemoteUrl The location of the full-size original attachment on the remote website.
	RemoteUrl *string `json:"remote_url"`

	// Type The type of the attachment.
	Type MediaAttachmentType `json:"type"`

	// Url The location of the original full-size attachment.
	Url string `json:"url"`
}

// MediaAttachmentType The type of the attachment.
type MediaAttachmentType string

// MediaImageForcus defines model for MediaImageForcus.
type MediaImageForcus struct {
	X *float32 `json:"x,omitempty"`
	Y *float32 `json:"y,omitempty"`
}

// MediaImageSize defines model for MediaImageSize.
type MediaImageSize struct {
	Aspect *float32 `json:"aspect,omitempty"`
	Height *int     `json:"height,omitempty"`
	Size   *string  `json:"size,omitempty"`
	Width  *int     `json:"width,omitempty"`
}

// MediaImegeMeta defines model for MediaImegeMeta.
type MediaImegeMeta struct {
	Focus    *MediaImageForcus `json:"focus,omitempty"`
	Original *MediaImageSize   `json:"original,omitempty"`
	Small    *MediaImageSize   `json:"small,omitempty"`
}

// Poll Represents a poll attached to a status.
type Poll struct {
	// Emojis Custom emoji to be used for rendering poll options.
	Emojis []CustomEmoji `json:"emojis"`

	// Expired Is the poll currently expired?
	Expired bool `json:"expired"`

	// ExpiresAt When the poll ends.
	ExpiresAt *string `json:"expires_at"`

	// Id The ID of the poll in the database.
	Id string `json:"id"`

	// Multiple Does the poll allow multiple-choice answers?
	Multiple bool `json:"multiple"`

	// Options Possible answers for the poll.
	Options []PollOption `json:"options"`

	// OwnVotes When called with a user token, which options has the authorized user chosen? Contains an array of index values for options.
	OwnVotes *[]int `json:"own_votes,omitempty"`

	// Voted When called with a user token, has the authorized user voted?
	Voted *bool `json:"voted,omitempty"`

	// VotersCount How many unique accounts have voted on a multiple-choice poll.
	VotersCount *int `json:"voters_count"`

	// VotesCount How many votes have been received.
	VotesCount int `json:"votes_count"`
}

// PollOption defines model for PollOption.
type PollOption struct {
	// Title The text value of the poll option.
	Title string `json:"title"`

	// VotesCount The total number of received votes for this option.
	VotesCount *int `json:"votes_count"`
}

// PreviewCard Represents a rich preview card that is generated using OpenGraph tags from a URL.
type PreviewCard struct {
	// AuthorName The author of the original resource.
	AuthorName string `json:"author_name"`

	// AuthorUrl A link to the author of the original resource.
	AuthorUrl string `json:"author_url"`

	// Blurhash A hash computed by the BlurHash algorithm, for generating colorful preview thumbnails when media has not been downloaded yet.
	Blurhash *string `json:"blurhash"`

	// Description Description of preview.
	Description string `json:"description"`

	// EmbedUrl Used for photo embeds, instead of custom html.
	EmbedUrl string `json:"embed_url"`

	// Height Height of preview, in pixels.
	Height int `json:"height"`

	// Html HTML to be used for generating the preview card.
	Html string `json:"html"`

	// Image Preview thumbnail.
	Image *string `json:"image"`

	// ProviderName The provider of the original resource.
	ProviderName string `json:"provider_name"`

	// ProviderUrl A link to the provider of the original resource.
	ProviderUrl string `json:"provider_url"`

	// Title Title of linked resource.
	Title string `json:"title"`

	// Type The type of the preview card.
	Type PreviewCardType `json:"type"`

	// Url Location of linked resource.
	Url string `json:"url"`

	// Width Width of preview, in pixels.
	Width int `json:"width"`
}

// PreviewCardType The type of the preview card.
type PreviewCardType string

// Role defines model for Role.
type Role struct {
	// Color The hex code assigned to this role. If no hex code is assigned, the string will be empty.
	Color string `json:"color"`

	// Highlighted  Whether the role is publicly visible as a badge on user profiles.
	Highlighted bool `json:"highlighted"`

	// Id The ID of the Role in the database.
	Id int `json:"id"`

	// Name The name of the role.
	Name string `json:"name"`

	// Permissions A bitmask that represents the sum of all permissions granted to the role.
	Permissions int `json:"permissions"`
}

// Source defines model for Source.
type Source struct {
	// Fields Metadata about the account.
	Fields []Field `json:"fields"`

	// FollowRequestsCount The number of pending follow requests.
	FollowRequestsCount int `json:"follow_requests_count"`

	// Language The default posting language for new statuses. (ISO 639-1 language two-letter code) or empty string.
	Language string `json:"language"`

	// Note Profile bio, in plain-text instead of in HTML.
	Note string `json:"note"`

	// Privacy The default post privacy to be used for new statuses.
	Privacy SourcePrivacy `json:"privacy"`

	// Sensitive Whether new statuses should be marked sensitive by default.
	Sensitive bool `json:"sensitive"`
}

// SourcePrivacy The default post privacy to be used for new statuses.
type SourcePrivacy string

// Status defines model for Status.
type Status struct {
	Account     Account      `json:"account"`
	Application *Application `json:"application,omitempty"`

	// Bookmarked If the current token has an authorized user: Have you bookmarked this status?
	Bookmarked *bool       `json:"bookmarked,omitempty"`
	Card       Status_Card `json:"card"`

	// Content HTML-encoded status content.
	Content string `json:"content"`

	// CreatedAt The date when this status was created.
	CreatedAt string `json:"created_at"`

	// EditedAt Timestamp of when the status was last edited.
	EditedAt *string `json:"edited_at"`

	// Emojis Custom emoji to be used when rendering status content.
	Emojis []CustomEmoji `json:"emojis"`

	// Favourited If the current token has an authorized user: Have you favourited this status?
	Favourited *bool `json:"favourited,omitempty"`

	// FavouritesCount How many favourites this status has received.
	FavouritesCount int `json:"favourites_count"`

	// Filtered If the current token has an authorized user: The filter and keywords that matched this status.
	Filtered *[]FilterResult `json:"filtered,omitempty"`

	// Id ID of the status in the database.
	Id string `json:"id"`

	// InReplyToAccountId ID of the account that authored the status being replied to.
	InReplyToAccountId *string `json:"in_reply_to_account_id"`

	// InReplyToId ID of the status being replied to.
	InReplyToId *string `json:"in_reply_to_id"`

	// Language Primary language of this status.
	Language *string `json:"language"`

	// MediaAttachments Media that is attached to this status.
	MediaAttachments []MediaAttachment `json:"media_attachments"`

	// Mentions Mentions of users within the status content.
	Mentions []StatusMention `json:"mentions"`

	// Muted If the current token has an authorized user: Have you muted notifications for this status’s conversation?
	Muted *bool `json:"muted,omitempty"`

	// Pinned If the current token has an authorized user: Have you pinned this status? Only appears if the status is pinnable.
	Pinned *bool       `json:"pinned,omitempty"`
	Poll   Status_Poll `json:"poll"`

	// Reblog The status being reblogged.
	Reblog Status_Reblog `json:"reblog"`

	// Reblogged If the current token has an authorized user: Have you boosted this status?
	Reblogged *bool `json:"reblogged,omitempty"`

	// ReblogsCount How many boosts this status has received.
	ReblogsCount int `json:"reblogs_count"`

	// RepliesCount How many replies this status has received.
	RepliesCount int `json:"replies_count"`

	// Sensitive Is this status marked as sensitive content?
	Sensitive bool `json:"sensitive"`

	// SpoilerText Subject or summary line, below which status content is collapsed until expanded.
	SpoilerText string `json:"spoiler_text"`

	// Tags Hashtags used within the status content.
	Tags []StatusTag `json:"tags"`

	// Text Plain-text source of a status. Returned instead of content when status is deleted, so the user may redraft from the source text without the client having to reverse-engineer the original text from the HTML content.
	Text *string `json:"text"`

	// Uri URI of the status used for federation.
	Uri string `json:"uri"`

	// Url A link to the status’s HTML representation.
	Url *string `json:"url"`

	// Visibility Visibility of this status.
	Visibility StatusVisibility `json:"visibility"`
}

// StatusCard1 defines model for .
type StatusCard1 = map[string]interface{}

// Status_Card defines model for Status.Card.
type Status_Card struct {
	union json.RawMessage
}

// StatusPoll1 defines model for .
type StatusPoll1 = map[string]interface{}

// Status_Poll defines model for Status.Poll.
type Status_Poll struct {
	union json.RawMessage
}

// StatusReblog1 defines model for .
type StatusReblog1 = map[string]interface{}

// Status_Reblog The status being reblogged.
type Status_Reblog struct {
	union json.RawMessage
}

// StatusVisibility Visibility of this status.
type StatusVisibility string

// StatusMention defines model for StatusMention.
type StatusMention struct {
	// Acct The webfinger acct: URI of the mentioned user. Equivalent to username for local users, or username@domain for remote users.
	Acct string `json:"acct"`

	// Id The account ID of the mentioned user.
	Id string `json:"id"`

	// Url The location of the mentioned user’s profile.
	Url string `json:"url"`

	// Username The username of the mentioned user.
	Username string `json:"username"`
}

// StatusOrign Represents a status posted by an account.
type StatusOrign struct {
	Account     Account      `json:"account"`
	Application *Application `json:"application,omitempty"`

	// Bookmarked If the current token has an authorized user: Have you bookmarked this status?
	Bookmarked *bool            `json:"bookmarked,omitempty"`
	Card       StatusOrign_Card `json:"card"`

	// Content HTML-encoded status content.
	Content string `json:"content"`

	// CreatedAt The date when this status was created.
	CreatedAt string `json:"created_at"`

	// EditedAt Timestamp of when the status was last edited.
	EditedAt *string `json:"edited_at"`

	// Emojis Custom emoji to be used when rendering status content.
	Emojis []CustomEmoji `json:"emojis"`

	// Favourited If the current token has an authorized user: Have you favourited this status?
	Favourited *bool `json:"favourited,omitempty"`

	// FavouritesCount How many favourites this status has received.
	FavouritesCount int `json:"favourites_count"`

	// Filtered If the current token has an authorized user: The filter and keywords that matched this status.
	Filtered *[]FilterResult `json:"filtered,omitempty"`

	// Id ID of the status in the database.
	Id string `json:"id"`

	// InReplyToAccountId ID of the account that authored the status being replied to.
	InReplyToAccountId *string `json:"in_reply_to_account_id"`

	// InReplyToId ID of the status being replied to.
	InReplyToId *string `json:"in_reply_to_id"`

	// Language Primary language of this status.
	Language *string `json:"language"`

	// MediaAttachments Media that is attached to this status.
	MediaAttachments []MediaAttachment `json:"media_attachments"`

	// Mentions Mentions of users within the status content.
	Mentions []StatusMention `json:"mentions"`

	// Muted If the current token has an authorized user: Have you muted notifications for this status’s conversation?
	Muted *bool `json:"muted,omitempty"`

	// Pinned If the current token has an authorized user: Have you pinned this status? Only appears if the status is pinnable.
	Pinned *bool            `json:"pinned,omitempty"`
	Poll   StatusOrign_Poll `json:"poll"`

	// Reblogged If the current token has an authorized user: Have you boosted this status?
	Reblogged *bool `json:"reblogged,omitempty"`

	// ReblogsCount How many boosts this status has received.
	ReblogsCount int `json:"reblogs_count"`

	// RepliesCount How many replies this status has received.
	RepliesCount int `json:"replies_count"`

	// Sensitive Is this status marked as sensitive content?
	Sensitive bool `json:"sensitive"`

	// SpoilerText Subject or summary line, below which status content is collapsed until expanded.
	SpoilerText string `json:"spoiler_text"`

	// Tags Hashtags used within the status content.
	Tags []StatusTag `json:"tags"`

	// Text Plain-text source of a status. Returned instead of content when status is deleted, so the user may redraft from the source text without the client having to reverse-engineer the original text from the HTML content.
	Text *string `json:"text"`

	// Uri URI of the status used for federation.
	Uri string `json:"uri"`

	// Url A link to the status’s HTML representation.
	Url *string `json:"url"`

	// Visibility Visibility of this status.
	Visibility StatusOrignVisibility `json:"visibility"`
}

// StatusOrignCard1 defines model for .
type StatusOrignCard1 = map[string]interface{}

// StatusOrign_Card defines model for StatusOrign.Card.
type StatusOrign_Card struct {
	union json.RawMessage
}

// StatusOrignPoll1 defines model for .
type StatusOrignPoll1 = map[string]interface{}

// StatusOrign_Poll defines model for StatusOrign.Poll.
type StatusOrign_Poll struct {
	union json.RawMessage
}

// StatusOrignVisibility Visibility of this status.
type StatusOrignVisibility string

// StatusReblog defines model for StatusReblog.
type StatusReblog struct {
	Account     Account      `json:"account"`
	Application *Application `json:"application,omitempty"`

	// Bookmarked If the current token has an authorized user: Have you bookmarked this status?
	Bookmarked *bool             `json:"bookmarked,omitempty"`
	Card       StatusReblog_Card `json:"card"`

	// Content HTML-encoded status content.
	Content string `json:"content"`

	// CreatedAt The date when this status was created.
	CreatedAt string `json:"created_at"`

	// EditedAt Timestamp of when the status was last edited.
	EditedAt *string `json:"edited_at"`

	// Emojis Custom emoji to be used when rendering status content.
	Emojis []CustomEmoji `json:"emojis"`

	// Favourited If the current token has an authorized user: Have you favourited this status?
	Favourited *bool `json:"favourited,omitempty"`

	// FavouritesCount How many favourites this status has received.
	FavouritesCount int `json:"favourites_count"`

	// Filtered If the current token has an authorized user: The filter and keywords that matched this status.
	Filtered *[]FilterResult `json:"filtered,omitempty"`

	// Id ID of the status in the database.
	Id string `json:"id"`

	// InReplyToAccountId ID of the account that authored the status being replied to.
	InReplyToAccountId *string `json:"in_reply_to_account_id"`

	// InReplyToId ID of the status being replied to.
	InReplyToId *string `json:"in_reply_to_id"`

	// Language Primary language of this status.
	Language *string `json:"language"`

	// MediaAttachments Media that is attached to this status.
	MediaAttachments []MediaAttachment `json:"media_attachments"`

	// Mentions Mentions of users within the status content.
	Mentions []StatusMention `json:"mentions"`

	// Muted If the current token has an authorized user: Have you muted notifications for this status’s conversation?
	Muted *bool `json:"muted,omitempty"`

	// Pinned If the current token has an authorized user: Have you pinned this status? Only appears if the status is pinnable.
	Pinned *bool                   `json:"pinned,omitempty"`
	Poll   StatusReblog_Poll       `json:"poll"`
	Reblog *map[string]interface{} `json:"reblog"`

	// Reblogged If the current token has an authorized user: Have you boosted this status?
	Reblogged *bool `json:"reblogged,omitempty"`

	// ReblogsCount How many boosts this status has received.
	ReblogsCount int `json:"reblogs_count"`

	// RepliesCount How many replies this status has received.
	RepliesCount int `json:"replies_count"`

	// Sensitive Is this status marked as sensitive content?
	Sensitive bool `json:"sensitive"`

	// SpoilerText Subject or summary line, below which status content is collapsed until expanded.
	SpoilerText string `json:"spoiler_text"`

	// Tags Hashtags used within the status content.
	Tags []StatusTag `json:"tags"`

	// Text Plain-text source of a status. Returned instead of content when status is deleted, so the user may redraft from the source text without the client having to reverse-engineer the original text from the HTML content.
	Text *string `json:"text"`

	// Uri URI of the status used for federation.
	Uri string `json:"uri"`

	// Url A link to the status’s HTML representation.
	Url *string `json:"url"`

	// Visibility Visibility of this status.
	Visibility StatusReblogVisibility `json:"visibility"`
}

// StatusReblogCard1 defines model for .
type StatusReblogCard1 = map[string]interface{}

// StatusReblog_Card defines model for StatusReblog.Card.
type StatusReblog_Card struct {
	union json.RawMessage
}

// StatusReblogPoll1 defines model for .
type StatusReblogPoll1 = map[string]interface{}

// StatusReblog_Poll defines model for StatusReblog.Poll.
type StatusReblog_Poll struct {
	union json.RawMessage
}

// StatusReblogVisibility Visibility of this status.
type StatusReblogVisibility string

// StatusTag defines model for StatusTag.
type StatusTag struct {
	// Name The value of the hashtag after the # sign.
	Name string `json:"name"`

	// Url A link to the hashtag on the instance.
	Url string `json:"url"`
}

// ArrayAllQueryParam defines model for ArrayAllQueryParam.
type ArrayAllQueryParam = []interface{}

// ArrayAnyQueryParam defines model for ArrayAnyQueryParam.
type ArrayAnyQueryParam = []interface{}

// ArrayNoneQueryParam defines model for ArrayNoneQueryParam.
type ArrayNoneQueryParam = []interface{}

// ExcludeReblogsQueryParam defines model for ExcludeReblogsQueryParam.
type ExcludeReblogsQueryParam = bool

// ExcludeRepliesQueryParam defines model for ExcludeRepliesQueryParam.
type ExcludeRepliesQueryParam = bool

// HashTagPathParam defines model for HashTagPathParam.
type HashTagPathParam = string

// IsLocalParam defines model for IsLocalParam.
type IsLocalParam = bool

// IsRemoteparam defines model for IsRemoteparam.
type IsRemoteparam = bool

// LimitQueryParam defines model for LimitQueryParam.
type LimitQueryParam = int

// MaxIdQueryParam defines model for MaxIdQueryParam.
type MaxIdQueryParam = string

// MinIdQueryParam defines model for MinIdQueryParam.
type MinIdQueryParam = string

// OnlyMediaQueryParam defines model for OnlyMediaQueryParam.
type OnlyMediaQueryParam = bool

// PinnedQueryParam defines model for PinnedQueryParam.
type PinnedQueryParam = bool

// SinceIdQueryParam defines model for SinceIdQueryParam.
type SinceIdQueryParam = string

// TaggedQueryParam defines model for TaggedQueryParam.
type TaggedQueryParam = string

// GetApiV1AccountsUidStatusesParams defines parameters for GetApiV1AccountsUidStatuses.
type GetApiV1AccountsUidStatusesParams struct {
	// MaxId Return results older than this ID
	MaxId *MaxIdQueryParam `form:"max_id,omitempty" json:"max_id,omitempty"`

	// SinceId Return results newer than this ID
	SinceId *SinceIdQueryParam `form:"since_id,omitempty" json:"since_id,omitempty"`

	// MinId Return results immediately newer than this ID
	MinId *MinIdQueryParam `form:"min_id,omitempty" json:"min_id,omitempty"`

	// Limit Maximum number of results to return. Defaults to 20 statuses. Max 40 statuses.
	Limit *LimitQueryParam `form:"limit,omitempty" json:"limit,omitempty"`

	// OnlyMedia Filter out statuses without attachments.
	OnlyMedia *OnlyMediaQueryParam `form:"only_media,omitempty" json:"only_media,omitempty"`

	// ExcludeReplies Filter out statuses in reply to a different account.
	ExcludeReplies *ExcludeRepliesQueryParam `form:"exclude_replies,omitempty" json:"exclude_replies,omitempty"`

	// ExcludeReblogs Filter out boosts from the response.
	ExcludeReblogs *ExcludeReblogsQueryParam `form:"exclude_reblogs,omitempty" json:"exclude_reblogs,omitempty"`

	// Pinned Filter for pinned statuses only.
	Pinned *PinnedQueryParam `form:"pinned,omitempty" json:"pinned,omitempty"`

	// Tagged Filter for statuses using a specific hashtag.
	Tagged *TaggedQueryParam `form:"tagged,omitempty" json:"tagged,omitempty"`
}

// GetApiV1TimelinesHomeParams defines parameters for GetApiV1TimelinesHome.
type GetApiV1TimelinesHomeParams struct {
	// MaxId Return results older than this ID
	MaxId *MaxIdQueryParam `form:"max_id,omitempty" json:"max_id,omitempty"`

	// SinceId Return results newer than this ID
	SinceId *SinceIdQueryParam `form:"since_id,omitempty" json:"since_id,omitempty"`

	// MinId Return results immediately newer than this ID
	MinId *MinIdQueryParam `form:"min_id,omitempty" json:"min_id,omitempty"`

	// Limit Maximum number of results to return. Defaults to 20 statuses. Max 40 statuses.
	Limit *LimitQueryParam `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetApiV1TimelinesListListIdParams defines parameters for GetApiV1TimelinesListListId.
type GetApiV1TimelinesListListIdParams struct {
	// MaxId Return results older than this ID
	MaxId *MaxIdQueryParam `form:"max_id,omitempty" json:"max_id,omitempty"`

	// SinceId Return results newer than this ID
	SinceId *SinceIdQueryParam `form:"since_id,omitempty" json:"since_id,omitempty"`

	// MinId Return results immediately newer than this ID
	MinId *MinIdQueryParam `form:"min_id,omitempty" json:"min_id,omitempty"`

	// Limit Maximum number of results to return. Defaults to 20 statuses. Max 40 statuses.
	Limit *LimitQueryParam `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetApiV1TimelinesPublicParams defines parameters for GetApiV1TimelinesPublic.
type GetApiV1TimelinesPublicParams struct {
	// Local Boolean. Show only local statuses? Defaults to false.
	Local *IsLocalParam `form:"local,omitempty" json:"local,omitempty"`

	// Remote Boolean. Show only remote statuses? Defaults to false.
	Remote *IsRemoteparam `form:"remote,omitempty" json:"remote,omitempty"`

	// OnlyMedia Filter out statuses without attachments.
	OnlyMedia *OnlyMediaQueryParam `form:"only_media,omitempty" json:"only_media,omitempty"`

	// MaxId Return results older than this ID
	MaxId *MaxIdQueryParam `form:"max_id,omitempty" json:"max_id,omitempty"`

	// SinceId Return results newer than this ID
	SinceId *SinceIdQueryParam `form:"since_id,omitempty" json:"since_id,omitempty"`

	// MinId Return results immediately newer than this ID
	MinId *MinIdQueryParam `form:"min_id,omitempty" json:"min_id,omitempty"`

	// Limit Maximum number of results to return. Defaults to 20 statuses. Max 40 statuses.
	Limit *LimitQueryParam `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetApiV1TimelinesTagHashtagParams defines parameters for GetApiV1TimelinesTagHashtag.
type GetApiV1TimelinesTagHashtagParams struct {
	// Any Array of String. Return statuses that contain any of these additional tags.
	Any *ArrayAnyQueryParam `form:"any,omitempty" json:"any,omitempty"`

	// All Array of String. Return statuses that contain all of these additional tags.
	All *ArrayAllQueryParam `form:"all,omitempty" json:"all,omitempty"`

	// None Array of String. Return statuses that contain none of these additional tags.
	None *ArrayNoneQueryParam `form:"none,omitempty" json:"none,omitempty"`

	// Local Boolean. Show only local statuses? Defaults to false.
	Local *IsLocalParam `form:"local,omitempty" json:"local,omitempty"`

	// Remote Boolean. Show only remote statuses? Defaults to false.
	Remote *IsRemoteparam `form:"remote,omitempty" json:"remote,omitempty"`

	// OnlyMedia Filter out statuses without attachments.
	OnlyMedia *OnlyMediaQueryParam `form:"only_media,omitempty" json:"only_media,omitempty"`

	// MaxId Return results older than this ID
	MaxId *MaxIdQueryParam `form:"max_id,omitempty" json:"max_id,omitempty"`

	// SinceId Return results newer than this ID
	SinceId *SinceIdQueryParam `form:"since_id,omitempty" json:"since_id,omitempty"`

	// MinId Return results immediately newer than this ID
	MinId *MinIdQueryParam `form:"min_id,omitempty" json:"min_id,omitempty"`

	// Limit Maximum number of results to return. Defaults to 20 statuses. Max 40 statuses.
	Limit *LimitQueryParam `form:"limit,omitempty" json:"limit,omitempty"`
}

// AsPreviewCard returns the union data inside the Status_Card as a PreviewCard
func (t Status_Card) AsPreviewCard() (PreviewCard, error) {
	var body PreviewCard
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPreviewCard overwrites any union data inside the Status_Card as the provided PreviewCard
func (t *Status_Card) FromPreviewCard(v PreviewCard) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePreviewCard performs a merge with any union data inside the Status_Card, using the provided PreviewCard
func (t *Status_Card) MergePreviewCard(v PreviewCard) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsStatusCard1 returns the union data inside the Status_Card as a StatusCard1
func (t Status_Card) AsStatusCard1() (StatusCard1, error) {
	var body StatusCard1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStatusCard1 overwrites any union data inside the Status_Card as the provided StatusCard1
func (t *Status_Card) FromStatusCard1(v StatusCard1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStatusCard1 performs a merge with any union data inside the Status_Card, using the provided StatusCard1
func (t *Status_Card) MergeStatusCard1(v StatusCard1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t Status_Card) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Status_Card) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsPoll returns the union data inside the Status_Poll as a Poll
func (t Status_Poll) AsPoll() (Poll, error) {
	var body Poll
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPoll overwrites any union data inside the Status_Poll as the provided Poll
func (t *Status_Poll) FromPoll(v Poll) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePoll performs a merge with any union data inside the Status_Poll, using the provided Poll
func (t *Status_Poll) MergePoll(v Poll) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsStatusPoll1 returns the union data inside the Status_Poll as a StatusPoll1
func (t Status_Poll) AsStatusPoll1() (StatusPoll1, error) {
	var body StatusPoll1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStatusPoll1 overwrites any union data inside the Status_Poll as the provided StatusPoll1
func (t *Status_Poll) FromStatusPoll1(v StatusPoll1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStatusPoll1 performs a merge with any union data inside the Status_Poll, using the provided StatusPoll1
func (t *Status_Poll) MergeStatusPoll1(v StatusPoll1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t Status_Poll) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Status_Poll) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsStatusReblog returns the union data inside the Status_Reblog as a StatusReblog
func (t Status_Reblog) AsStatusReblog() (StatusReblog, error) {
	var body StatusReblog
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStatusReblog overwrites any union data inside the Status_Reblog as the provided StatusReblog
func (t *Status_Reblog) FromStatusReblog(v StatusReblog) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStatusReblog performs a merge with any union data inside the Status_Reblog, using the provided StatusReblog
func (t *Status_Reblog) MergeStatusReblog(v StatusReblog) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsStatusReblog1 returns the union data inside the Status_Reblog as a StatusReblog1
func (t Status_Reblog) AsStatusReblog1() (StatusReblog1, error) {
	var body StatusReblog1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStatusReblog1 overwrites any union data inside the Status_Reblog as the provided StatusReblog1
func (t *Status_Reblog) FromStatusReblog1(v StatusReblog1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStatusReblog1 performs a merge with any union data inside the Status_Reblog, using the provided StatusReblog1
func (t *Status_Reblog) MergeStatusReblog1(v StatusReblog1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t Status_Reblog) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Status_Reblog) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsPreviewCard returns the union data inside the StatusOrign_Card as a PreviewCard
func (t StatusOrign_Card) AsPreviewCard() (PreviewCard, error) {
	var body PreviewCard
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPreviewCard overwrites any union data inside the StatusOrign_Card as the provided PreviewCard
func (t *StatusOrign_Card) FromPreviewCard(v PreviewCard) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePreviewCard performs a merge with any union data inside the StatusOrign_Card, using the provided PreviewCard
func (t *StatusOrign_Card) MergePreviewCard(v PreviewCard) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsStatusOrignCard1 returns the union data inside the StatusOrign_Card as a StatusOrignCard1
func (t StatusOrign_Card) AsStatusOrignCard1() (StatusOrignCard1, error) {
	var body StatusOrignCard1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStatusOrignCard1 overwrites any union data inside the StatusOrign_Card as the provided StatusOrignCard1
func (t *StatusOrign_Card) FromStatusOrignCard1(v StatusOrignCard1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStatusOrignCard1 performs a merge with any union data inside the StatusOrign_Card, using the provided StatusOrignCard1
func (t *StatusOrign_Card) MergeStatusOrignCard1(v StatusOrignCard1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t StatusOrign_Card) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *StatusOrign_Card) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsPoll returns the union data inside the StatusOrign_Poll as a Poll
func (t StatusOrign_Poll) AsPoll() (Poll, error) {
	var body Poll
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPoll overwrites any union data inside the StatusOrign_Poll as the provided Poll
func (t *StatusOrign_Poll) FromPoll(v Poll) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePoll performs a merge with any union data inside the StatusOrign_Poll, using the provided Poll
func (t *StatusOrign_Poll) MergePoll(v Poll) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsStatusOrignPoll1 returns the union data inside the StatusOrign_Poll as a StatusOrignPoll1
func (t StatusOrign_Poll) AsStatusOrignPoll1() (StatusOrignPoll1, error) {
	var body StatusOrignPoll1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStatusOrignPoll1 overwrites any union data inside the StatusOrign_Poll as the provided StatusOrignPoll1
func (t *StatusOrign_Poll) FromStatusOrignPoll1(v StatusOrignPoll1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStatusOrignPoll1 performs a merge with any union data inside the StatusOrign_Poll, using the provided StatusOrignPoll1
func (t *StatusOrign_Poll) MergeStatusOrignPoll1(v StatusOrignPoll1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t StatusOrign_Poll) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *StatusOrign_Poll) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsPreviewCard returns the union data inside the StatusReblog_Card as a PreviewCard
func (t StatusReblog_Card) AsPreviewCard() (PreviewCard, error) {
	var body PreviewCard
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPreviewCard overwrites any union data inside the StatusReblog_Card as the provided PreviewCard
func (t *StatusReblog_Card) FromPreviewCard(v PreviewCard) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePreviewCard performs a merge with any union data inside the StatusReblog_Card, using the provided PreviewCard
func (t *StatusReblog_Card) MergePreviewCard(v PreviewCard) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsStatusReblogCard1 returns the union data inside the StatusReblog_Card as a StatusReblogCard1
func (t StatusReblog_Card) AsStatusReblogCard1() (StatusReblogCard1, error) {
	var body StatusReblogCard1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStatusReblogCard1 overwrites any union data inside the StatusReblog_Card as the provided StatusReblogCard1
func (t *StatusReblog_Card) FromStatusReblogCard1(v StatusReblogCard1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStatusReblogCard1 performs a merge with any union data inside the StatusReblog_Card, using the provided StatusReblogCard1
func (t *StatusReblog_Card) MergeStatusReblogCard1(v StatusReblogCard1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t StatusReblog_Card) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *StatusReblog_Card) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsPoll returns the union data inside the StatusReblog_Poll as a Poll
func (t StatusReblog_Poll) AsPoll() (Poll, error) {
	var body Poll
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPoll overwrites any union data inside the StatusReblog_Poll as the provided Poll
func (t *StatusReblog_Poll) FromPoll(v Poll) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePoll performs a merge with any union data inside the StatusReblog_Poll, using the provided Poll
func (t *StatusReblog_Poll) MergePoll(v Poll) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsStatusReblogPoll1 returns the union data inside the StatusReblog_Poll as a StatusReblogPoll1
func (t StatusReblog_Poll) AsStatusReblogPoll1() (StatusReblogPoll1, error) {
	var body StatusReblogPoll1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStatusReblogPoll1 overwrites any union data inside the StatusReblog_Poll as the provided StatusReblogPoll1
func (t *StatusReblog_Poll) FromStatusReblogPoll1(v StatusReblogPoll1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStatusReblogPoll1 performs a merge with any union data inside the StatusReblog_Poll, using the provided StatusReblogPoll1
func (t *StatusReblog_Poll) MergeStatusReblogPoll1(v StatusReblogPoll1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t StatusReblog_Poll) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *StatusReblog_Poll) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Verify account credentials
	// (GET /api/v1/accounts/verify_credentials)
	GetApiV1AccountsVerifyCredentials(ctx echo.Context) error
	// Get account
	// (GET /api/v1/accounts/{uid})
	GetApiV1AccountsUid(ctx echo.Context, uid string) error
	// Get account’s statuses
	// (GET /api/v1/accounts/{uid}/statuses)
	GetApiV1AccountsUidStatuses(ctx echo.Context, uid string, params GetApiV1AccountsUidStatusesParams) error
	// View home timeline
	// (GET /api/v1/timelines/home)
	GetApiV1TimelinesHome(ctx echo.Context, params GetApiV1TimelinesHomeParams) error
	// View list timeline
	// (GET /api/v1/timelines/list/{lid})
	GetApiV1TimelinesListListId(ctx echo.Context, lid string, params GetApiV1TimelinesListListIdParams) error
	// View public timeline
	// (GET /api/v1/timelines/public)
	GetApiV1TimelinesPublic(ctx echo.Context, params GetApiV1TimelinesPublicParams) error
	// View hashtag timeline
	// (GET /api/v1/timelines/tag/{hashtag})
	GetApiV1TimelinesTagHashtag(ctx echo.Context, hashtag HashTagPathParam, params GetApiV1TimelinesTagHashtagParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// GetApiV1AccountsVerifyCredentials converts echo context to params.
func (w *ServerInterfaceWrapper) GetApiV1AccountsVerifyCredentials(ctx echo.Context) error {
	var err error

	ctx.Set(NPubOrNSecScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetApiV1AccountsVerifyCredentials(ctx)
	return err
}

// GetApiV1AccountsUid converts echo context to params.
func (w *ServerInterfaceWrapper) GetApiV1AccountsUid(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "uid" -------------
	var uid string

	err = runtime.BindStyledParameterWithLocation("simple", false, "uid", runtime.ParamLocationPath, ctx.Param("uid"), &uid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter uid: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetApiV1AccountsUid(ctx, uid)
	return err
}

// GetApiV1AccountsUidStatuses converts echo context to params.
func (w *ServerInterfaceWrapper) GetApiV1AccountsUidStatuses(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "uid" -------------
	var uid string

	err = runtime.BindStyledParameterWithLocation("simple", false, "uid", runtime.ParamLocationPath, ctx.Param("uid"), &uid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter uid: %s", err))
	}

	ctx.Set(NPubOrNSecScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApiV1AccountsUidStatusesParams
	// ------------- Optional query parameter "max_id" -------------

	err = runtime.BindQueryParameter("form", true, false, "max_id", ctx.QueryParams(), &params.MaxId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max_id: %s", err))
	}

	// ------------- Optional query parameter "since_id" -------------

	err = runtime.BindQueryParameter("form", true, false, "since_id", ctx.QueryParams(), &params.SinceId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter since_id: %s", err))
	}

	// ------------- Optional query parameter "min_id" -------------

	err = runtime.BindQueryParameter("form", true, false, "min_id", ctx.QueryParams(), &params.MinId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min_id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "only_media" -------------

	err = runtime.BindQueryParameter("form", true, false, "only_media", ctx.QueryParams(), &params.OnlyMedia)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter only_media: %s", err))
	}

	// ------------- Optional query parameter "exclude_replies" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude_replies", ctx.QueryParams(), &params.ExcludeReplies)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude_replies: %s", err))
	}

	// ------------- Optional query parameter "exclude_reblogs" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude_reblogs", ctx.QueryParams(), &params.ExcludeReblogs)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude_reblogs: %s", err))
	}

	// ------------- Optional query parameter "pinned" -------------

	err = runtime.BindQueryParameter("form", true, false, "pinned", ctx.QueryParams(), &params.Pinned)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter pinned: %s", err))
	}

	// ------------- Optional query parameter "tagged" -------------

	err = runtime.BindQueryParameter("form", true, false, "tagged", ctx.QueryParams(), &params.Tagged)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tagged: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetApiV1AccountsUidStatuses(ctx, uid, params)
	return err
}

// GetApiV1TimelinesHome converts echo context to params.
func (w *ServerInterfaceWrapper) GetApiV1TimelinesHome(ctx echo.Context) error {
	var err error

	ctx.Set(NPubOrNSecScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApiV1TimelinesHomeParams
	// ------------- Optional query parameter "max_id" -------------

	err = runtime.BindQueryParameter("form", true, false, "max_id", ctx.QueryParams(), &params.MaxId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max_id: %s", err))
	}

	// ------------- Optional query parameter "since_id" -------------

	err = runtime.BindQueryParameter("form", true, false, "since_id", ctx.QueryParams(), &params.SinceId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter since_id: %s", err))
	}

	// ------------- Optional query parameter "min_id" -------------

	err = runtime.BindQueryParameter("form", true, false, "min_id", ctx.QueryParams(), &params.MinId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min_id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetApiV1TimelinesHome(ctx, params)
	return err
}

// GetApiV1TimelinesListListId converts echo context to params.
func (w *ServerInterfaceWrapper) GetApiV1TimelinesListListId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "lid" -------------
	var lid string

	err = runtime.BindStyledParameterWithLocation("simple", false, "lid", runtime.ParamLocationPath, ctx.Param("lid"), &lid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter lid: %s", err))
	}

	ctx.Set(NPubOrNSecScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApiV1TimelinesListListIdParams
	// ------------- Optional query parameter "max_id" -------------

	err = runtime.BindQueryParameter("form", true, false, "max_id", ctx.QueryParams(), &params.MaxId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max_id: %s", err))
	}

	// ------------- Optional query parameter "since_id" -------------

	err = runtime.BindQueryParameter("form", true, false, "since_id", ctx.QueryParams(), &params.SinceId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter since_id: %s", err))
	}

	// ------------- Optional query parameter "min_id" -------------

	err = runtime.BindQueryParameter("form", true, false, "min_id", ctx.QueryParams(), &params.MinId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min_id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetApiV1TimelinesListListId(ctx, lid, params)
	return err
}

// GetApiV1TimelinesPublic converts echo context to params.
func (w *ServerInterfaceWrapper) GetApiV1TimelinesPublic(ctx echo.Context) error {
	var err error

	ctx.Set(NPubOrNSecScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApiV1TimelinesPublicParams
	// ------------- Optional query parameter "local" -------------

	err = runtime.BindQueryParameter("form", true, false, "local", ctx.QueryParams(), &params.Local)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter local: %s", err))
	}

	// ------------- Optional query parameter "remote" -------------

	err = runtime.BindQueryParameter("form", true, false, "remote", ctx.QueryParams(), &params.Remote)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter remote: %s", err))
	}

	// ------------- Optional query parameter "only_media" -------------

	err = runtime.BindQueryParameter("form", true, false, "only_media", ctx.QueryParams(), &params.OnlyMedia)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter only_media: %s", err))
	}

	// ------------- Optional query parameter "max_id" -------------

	err = runtime.BindQueryParameter("form", true, false, "max_id", ctx.QueryParams(), &params.MaxId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max_id: %s", err))
	}

	// ------------- Optional query parameter "since_id" -------------

	err = runtime.BindQueryParameter("form", true, false, "since_id", ctx.QueryParams(), &params.SinceId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter since_id: %s", err))
	}

	// ------------- Optional query parameter "min_id" -------------

	err = runtime.BindQueryParameter("form", true, false, "min_id", ctx.QueryParams(), &params.MinId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min_id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetApiV1TimelinesPublic(ctx, params)
	return err
}

// GetApiV1TimelinesTagHashtag converts echo context to params.
func (w *ServerInterfaceWrapper) GetApiV1TimelinesTagHashtag(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "hashtag" -------------
	var hashtag HashTagPathParam

	err = runtime.BindStyledParameterWithLocation("simple", false, "hashtag", runtime.ParamLocationPath, ctx.Param("hashtag"), &hashtag)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtag: %s", err))
	}

	ctx.Set(NPubOrNSecScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApiV1TimelinesTagHashtagParams
	// ------------- Optional query parameter "any" -------------

	err = runtime.BindQueryParameter("form", true, false, "any", ctx.QueryParams(), &params.Any)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter any: %s", err))
	}

	// ------------- Optional query parameter "all" -------------

	err = runtime.BindQueryParameter("form", true, false, "all", ctx.QueryParams(), &params.All)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter all: %s", err))
	}

	// ------------- Optional query parameter "none" -------------

	err = runtime.BindQueryParameter("form", true, false, "none", ctx.QueryParams(), &params.None)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter none: %s", err))
	}

	// ------------- Optional query parameter "local" -------------

	err = runtime.BindQueryParameter("form", true, false, "local", ctx.QueryParams(), &params.Local)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter local: %s", err))
	}

	// ------------- Optional query parameter "remote" -------------

	err = runtime.BindQueryParameter("form", true, false, "remote", ctx.QueryParams(), &params.Remote)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter remote: %s", err))
	}

	// ------------- Optional query parameter "only_media" -------------

	err = runtime.BindQueryParameter("form", true, false, "only_media", ctx.QueryParams(), &params.OnlyMedia)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter only_media: %s", err))
	}

	// ------------- Optional query parameter "max_id" -------------

	err = runtime.BindQueryParameter("form", true, false, "max_id", ctx.QueryParams(), &params.MaxId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max_id: %s", err))
	}

	// ------------- Optional query parameter "since_id" -------------

	err = runtime.BindQueryParameter("form", true, false, "since_id", ctx.QueryParams(), &params.SinceId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter since_id: %s", err))
	}

	// ------------- Optional query parameter "min_id" -------------

	err = runtime.BindQueryParameter("form", true, false, "min_id", ctx.QueryParams(), &params.MinId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min_id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetApiV1TimelinesTagHashtag(ctx, hashtag, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/api/v1/accounts/verify_credentials", wrapper.GetApiV1AccountsVerifyCredentials)
	router.GET(baseURL+"/api/v1/accounts/:uid", wrapper.GetApiV1AccountsUid)
	router.GET(baseURL+"/api/v1/accounts/:uid/statuses", wrapper.GetApiV1AccountsUidStatuses)
	router.GET(baseURL+"/api/v1/timelines/home", wrapper.GetApiV1TimelinesHome)
	router.GET(baseURL+"/api/v1/timelines/list/:lid", wrapper.GetApiV1TimelinesListListId)
	router.GET(baseURL+"/api/v1/timelines/public", wrapper.GetApiV1TimelinesPublic)
	router.GET(baseURL+"/api/v1/timelines/tag/:hashtag", wrapper.GetApiV1TimelinesTagHashtag)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
