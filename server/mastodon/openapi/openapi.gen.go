// Package mopenapi provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.13.0 DO NOT EDIT.
package mopenapi

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

const (
	NPubOrNSecScopes = "NPubOrNSec.Scopes"
)

// Defines values for FilterContext.
const (
	FilterContextAccount       FilterContext = "account"
	FilterContextHome          FilterContext = "home"
	FilterContextNotifications FilterContext = "notifications"
	FilterContextPublic        FilterContext = "public"
	FilterContextThread        FilterContext = "thread"
)

// Defines values for FilterFilterAction.
const (
	Hide FilterFilterAction = "hide"
	Warn FilterFilterAction = "warn"
)

// Defines values for MediaAttachmentType.
const (
	MediaAttachmentTypeAudio   MediaAttachmentType = "audio"
	MediaAttachmentTypeGifv    MediaAttachmentType = "gifv"
	MediaAttachmentTypeImage   MediaAttachmentType = "image"
	MediaAttachmentTypeUnknown MediaAttachmentType = "unknown"
	MediaAttachmentTypeVideo   MediaAttachmentType = "video"
)

// Defines values for PreviewCardType.
const (
	PreviewCardTypeLink  PreviewCardType = "link"
	PreviewCardTypePhoto PreviewCardType = "photo"
	PreviewCardTypeRich  PreviewCardType = "rich"
	PreviewCardTypeVideo PreviewCardType = "video"
)

// Defines values for SourcePrivacy.
const (
	SourcePrivacyDirect   SourcePrivacy = "direct"
	SourcePrivacyPrivate  SourcePrivacy = "private"
	SourcePrivacyPublic   SourcePrivacy = "public"
	SourcePrivacyUnlisted SourcePrivacy = "unlisted"
)

// Defines values for StatusVisibility.
const (
	Direct   StatusVisibility = "direct"
	Private  StatusVisibility = "private"
	Public   StatusVisibility = "public"
	Unlisted StatusVisibility = "unlisted"
)

// Account defines model for Account.
type Account struct {
	// Acct The Webfinger account URI. Equal to username for local users, or username@domain for remote users.
	Acct string `json:"acct"`

	// Avatar An image icon that is shown next to statuses and in the profile. (URL)
	Avatar string `json:"avatar"`

	// AvatarStatic A static version of the avatar. Equal to avatar if its value is a static image; different if avatar is an animated GIF.
	AvatarStatic string `json:"avatar_static"`

	// Bot Indicates that the account may perform automated actions, may not be monitored, or identifies
	Bot bool `json:"bot"`

	// CreatedAt When the account was created. (ISO 8601)
	CreatedAt string `json:"created_at"`

	// Discoverable Whether the account has opted into discovery features such as the profile directory.
	Discoverable *bool `json:"discoverable"`

	// DisplayName The profile’s display name.
	DisplayName string `json:"display_name"`

	// Emojis Custom emoji entities to be used when rendering the profile.
	Emojis []CustomEmoji `json:"emojis"`

	// Fields Custom emoji entities to be used when rendering the profile.
	Fields []Field `json:"fields"`

	// FollowersCount The reported followers of this profile.
	FollowersCount int `json:"followers_count"`

	// FollowingCount The reported follows of this profile.
	FollowingCount int `json:"following_count"`

	// Group Indicates that the account represents a Group actor.
	Group bool `json:"group"`

	// Header An image banner that is shown above the profile and in profile cards.
	Header string `json:"header"`

	// HeaderStatic A static version of the header. Equal to header if its value is a static image; different if header is an animated GIF.
	HeaderStatic string `json:"header_static"`

	// Id The account id.
	Id string `json:"id"`

	// LastStatusAt When the most recent status was posted. (ISO 8601)
	LastStatusAt *string `json:"last_status_at"`

	// Limited An extra attribute returned only when an account is silenced. If true, indicates that the account should be hidden behind a warning screen.
	Limited *bool `json:"limited,omitempty"`

	// Locked Whether the account manually approves follow requests.
	Locked bool `json:"locked"`

	// Moved Indicates that the profile is currently inactive and that its user has moved to a new account.
	Moved *bool `json:"moved"`

	// Noindex Whether the local user has opted out of being indexed by search engines.
	Noindex *bool `json:"noindex"`

	// Note The profile’s bio or description. (HTML)
	Note string `json:"note"`

	// StatusesCount How many statuses are attached to this account.
	StatusesCount int `json:"statuses_count"`

	// Suspended An extra attribute returned only when an account is suspended.
	Suspended *bool `json:"suspended,omitempty"`

	// Url The location of the user’s profile page.
	Url string `json:"url"`

	// Username The username of the account, not including domain.
	Username string `json:"username"`
}

// Application defines model for Application.
type Application struct {
	Name    *string `json:"name"`
	Website *string `json:"website"`
}

// CredentialAccount defines model for CredentialAccount.
type CredentialAccount struct {
	// Acct The Webfinger account URI. Equal to username for local users, or username@domain for remote users.
	Acct string `json:"acct"`

	// Avatar An image icon that is shown next to statuses and in the profile. (URL)
	Avatar string `json:"avatar"`

	// AvatarStatic A static version of the avatar. Equal to avatar if its value is a static image; different if avatar is an animated GIF.
	AvatarStatic string `json:"avatar_static"`

	// Bot Indicates that the account may perform automated actions, may not be monitored, or identifies
	Bot bool `json:"bot"`

	// CreatedAt When the account was created. (ISO 8601)
	CreatedAt string `json:"created_at"`

	// Discoverable Whether the account has opted into discovery features such as the profile directory.
	Discoverable *bool `json:"discoverable"`

	// DisplayName The profile’s display name.
	DisplayName string `json:"display_name"`

	// Emojis Custom emoji entities to be used when rendering the profile.
	Emojis []CustomEmoji `json:"emojis"`

	// Fields Custom emoji entities to be used when rendering the profile.
	Fields []Field `json:"fields"`

	// FollowersCount The reported followers of this profile.
	FollowersCount int `json:"followers_count"`

	// FollowingCount The reported follows of this profile.
	FollowingCount int `json:"following_count"`

	// Group Indicates that the account represents a Group actor.
	Group bool `json:"group"`

	// Header An image banner that is shown above the profile and in profile cards.
	Header string `json:"header"`

	// HeaderStatic A static version of the header. Equal to header if its value is a static image; different if header is an animated GIF.
	HeaderStatic string `json:"header_static"`

	// Id The account id.
	Id string `json:"id"`

	// LastStatusAt When the most recent status was posted. (ISO 8601)
	LastStatusAt *string `json:"last_status_at"`

	// Limited An extra attribute returned only when an account is silenced. If true, indicates that the account should be hidden behind a warning screen.
	Limited *bool `json:"limited,omitempty"`

	// Locked Whether the account manually approves follow requests.
	Locked bool `json:"locked"`

	// Moved Indicates that the profile is currently inactive and that its user has moved to a new account.
	Moved *bool `json:"moved"`

	// Noindex Whether the local user has opted out of being indexed by search engines.
	Noindex *bool `json:"noindex"`

	// Note The profile’s bio or description. (HTML)
	Note   string `json:"note"`
	Role   Role   `json:"role"`
	Source Source `json:"source"`

	// StatusesCount How many statuses are attached to this account.
	StatusesCount int `json:"statuses_count"`

	// Suspended An extra attribute returned only when an account is suspended.
	Suspended *bool `json:"suspended,omitempty"`

	// Url The location of the user’s profile page.
	Url string `json:"url"`

	// Username The username of the account, not including domain.
	Username string `json:"username"`
}

// CustomEmoji defines model for CustomEmoji.
type CustomEmoji struct {
	// Category Used for sorting custom emoji in the picker.
	Category string `json:"category"`

	// Shortcode The name of the custom emoji.
	Shortcode string `json:"shortcode"`

	// StaticUrl A link to a static copy of the custom emoji.
	StaticUrl string `json:"static_url"`

	// Url A link to the custom emoji.
	Url string `json:"url"`

	// VisibleInPicker Whether this Emoji should be visible in the picker or unlisted.
	VisibleInPicker bool `json:"visible_in_picker"`
}

// Field defines model for Field.
type Field struct {
	// Name The key of a given field’s key-value pair.
	Name string `json:"name"`

	// Value The value associated with the name key.
	Value string `json:"value"`

	// VerifiedAt Timestamp of when the server verified a URL value for a rel=“me” link.
	VerifiedAt *string `json:"verified_at"`
}

// Filter Represents a user-defined filter for determining which statuses should not be shown to the user.
type Filter struct {
	// Context The contexts in which the filter should be applied.
	Context []FilterContext `json:"context"`

	// ExpiresAt When the filter should no longer be applied.
	ExpiresAt *string `json:"expires_at"`

	// FilterAction The action to be taken when a status matches this filter.
	FilterAction FilterFilterAction `json:"filter_action"`

	// Id The ID of the Filter in the database.
	Id string `json:"id"`

	// Keywords The keywords grouped under this filter.
	Keywords []FilterKeyword `json:"keywords"`

	// Statuses The statuses grouped under this filter.
	Statuses []FilterStatus `json:"statuses"`

	// Title A title given by the user to name the filter.
	Title string `json:"title"`
}

// FilterContext defines model for Filter.Context.
type FilterContext string

// FilterFilterAction The action to be taken when a status matches this filter.
type FilterFilterAction string

// FilterKeyword Represents a keyword that, if matched, should cause the filter action to be taken.
type FilterKeyword struct {
	// Id The ID of the FilterKeyword in the database.
	Id string `json:"id"`

	// Keyword The phrase to be matched against.
	Keyword string `json:"keyword"`

	// WholeWord Should the filter consider word boundaries? See implementation guidelines for filters.
	WholeWord bool `json:"whole_word"`
}

// FilterResult Represents a filter whose keywords matched a given status.
type FilterResult struct {
	// Filter Represents a user-defined filter for determining which statuses should not be shown to the user.
	Filter Filter `json:"filter"`

	// KeywordMatches The keyword within the filter that was matched.
	KeywordMatches *[]string `json:"keyword_matches"`

	// StatusMatches The status ID within the filter that was matched.
	StatusMatches *[]string `json:"status_matches"`
}

// FilterStatus Represents a status ID that, if matched, should cause the filter action to be taken.
type FilterStatus struct {
	// Id The ID of the FilterStatus in the database.
	Id string `json:"id"`

	// StatusId The ID of the Status that will be filtered.
	StatusId string `json:"status_id"`
}

// MediaAttachment defines model for MediaAttachment.
type MediaAttachment struct {
	// Blurhash A hash computed by the BlurHash algorithm, for generating colorful preview thumbnails when media has not been downloaded yet.
	Blurhash string `json:"blurhash"`

	// Description Alternate text that describes what is in the media attachment, to be used for the visually impaired or when media attachments do not load.
	Description string `json:"description"`

	// Id The ID of the attachment in the database.
	Id   string         `json:"id"`
	Meta MediaImegeMeta `json:"meta"`

	// PreviewUrl The location of a scaled-down preview of the attachment.
	PreviewUrl string `json:"preview_url"`

	// RemoteUrl The location of the full-size original attachment on the remote website.
	RemoteUrl *string `json:"remote_url"`

	// Type The type of the attachment.
	Type MediaAttachmentType `json:"type"`

	// Url The location of the original full-size attachment.
	Url string `json:"url"`
}

// MediaAttachmentType The type of the attachment.
type MediaAttachmentType string

// MediaImageForcus defines model for MediaImageForcus.
type MediaImageForcus struct {
	X *float32 `json:"x,omitempty"`
	Y *float32 `json:"y,omitempty"`
}

// MediaImageSize defines model for MediaImageSize.
type MediaImageSize struct {
	Aspect *float32 `json:"aspect,omitempty"`
	Height *int     `json:"height,omitempty"`
	Size   *string  `json:"size,omitempty"`
	Width  *int     `json:"width,omitempty"`
}

// MediaImegeMeta defines model for MediaImegeMeta.
type MediaImegeMeta struct {
	Focus    *MediaImageForcus `json:"focus,omitempty"`
	Original *MediaImageSize   `json:"original,omitempty"`
	Small    *MediaImageSize   `json:"small,omitempty"`
}

// Poll Represents a poll attached to a status.
type Poll struct {
	// Emojis Custom emoji to be used for rendering poll options.
	Emojis []CustomEmoji `json:"emojis"`

	// Expired Is the poll currently expired?
	Expired bool `json:"expired"`

	// ExpiresAt When the poll ends.
	ExpiresAt *string `json:"expires_at"`

	// Id The ID of the poll in the database.
	Id string `json:"id"`

	// Multiple Does the poll allow multiple-choice answers?
	Multiple bool `json:"multiple"`

	// Options Possible answers for the poll.
	Options []PollOption `json:"options"`

	// OwnVotes When called with a user token, which options has the authorized user chosen? Contains an array of index values for options.
	OwnVotes *[]int `json:"own_votes,omitempty"`

	// Voted When called with a user token, has the authorized user voted?
	Voted *bool `json:"voted,omitempty"`

	// VotersCount How many unique accounts have voted on a multiple-choice poll.
	VotersCount *int `json:"voters_count"`

	// VotesCount How many votes have been received.
	VotesCount int `json:"votes_count"`
}

// PollOption defines model for PollOption.
type PollOption struct {
	// Title The text value of the poll option.
	Title string `json:"title"`

	// VotesCount The total number of received votes for this option.
	VotesCount *int `json:"votes_count"`
}

// PreviewCard Represents a rich preview card that is generated using OpenGraph tags from a URL.
type PreviewCard struct {
	// AuthorName The author of the original resource.
	AuthorName string `json:"author_name"`

	// AuthorUrl A link to the author of the original resource.
	AuthorUrl string `json:"author_url"`

	// Blurhash A hash computed by the BlurHash algorithm, for generating colorful preview thumbnails when media has not been downloaded yet.
	Blurhash *string `json:"blurhash"`

	// Description Description of preview.
	Description string `json:"description"`

	// EmbedUrl Used for photo embeds, instead of custom html.
	EmbedUrl string `json:"embed_url"`

	// Height Height of preview, in pixels.
	Height int `json:"height"`

	// Html HTML to be used for generating the preview card.
	Html string `json:"html"`

	// Image Preview thumbnail.
	Image *string `json:"image"`

	// ProviderName The provider of the original resource.
	ProviderName string `json:"provider_name"`

	// ProviderUrl A link to the provider of the original resource.
	ProviderUrl string `json:"provider_url"`

	// Title Title of linked resource.
	Title string `json:"title"`

	// Type The type of the preview card.
	Type PreviewCardType `json:"type"`

	// Url Location of linked resource.
	Url string `json:"url"`

	// Width Width of preview, in pixels.
	Width int `json:"width"`
}

// PreviewCardType The type of the preview card.
type PreviewCardType string

// Role defines model for Role.
type Role struct {
	// Color The hex code assigned to this role. If no hex code is assigned, the string will be empty.
	Color string `json:"color"`

	// Highlighted  Whether the role is publicly visible as a badge on user profiles.
	Highlighted bool `json:"highlighted"`

	// Id The ID of the Role in the database.
	Id int `json:"id"`

	// Name The name of the role.
	Name string `json:"name"`

	// Permissions A bitmask that represents the sum of all permissions granted to the role.
	Permissions int `json:"permissions"`
}

// Source defines model for Source.
type Source struct {
	// Fields Metadata about the account.
	Fields []Field `json:"fields"`

	// FollowRequestsCount The number of pending follow requests.
	FollowRequestsCount int `json:"follow_requests_count"`

	// Language The default posting language for new statuses. (ISO 639-1 language two-letter code) or empty string.
	Language string `json:"language"`

	// Note Profile bio, in plain-text instead of in HTML.
	Note string `json:"note"`

	// Privacy The default post privacy to be used for new statuses.
	Privacy SourcePrivacy `json:"privacy"`

	// Sensitive Whether new statuses should be marked sensitive by default.
	Sensitive bool `json:"sensitive"`
}

// SourcePrivacy The default post privacy to be used for new statuses.
type SourcePrivacy string

// Status Represents a status posted by an account.
type Status struct {
	Account     Account      `json:"account"`
	Application *Application `json:"application,omitempty"`

	// Bookmarked If the current token has an authorized user: Have you bookmarked this status?
	Bookmarked *bool `json:"bookmarked,omitempty"`

	// Card Represents a rich preview card that is generated using OpenGraph tags from a URL.
	Card PreviewCard `json:"card"`

	// Content HTML-encoded status content.
	Content string `json:"content"`

	// CreatedAt The date when this status was created.
	CreatedAt string `json:"created_at"`

	// EditedAt Timestamp of when the status was last edited.
	EditedAt *string `json:"edited_at"`

	// Emojis Custom emoji to be used when rendering status content.
	Emojis []CustomEmoji `json:"emojis"`

	// Favourited If the current token has an authorized user: Have you favourited this status?
	Favourited *bool `json:"favourited,omitempty"`

	// FavouritesCount How many favourites this status has received.
	FavouritesCount int `json:"favourites_count"`

	// Filtered If the current token has an authorized user: The filter and keywords that matched this status.
	Filtered *[]FilterResult `json:"filtered,omitempty"`

	// Id ID of the status in the database.
	Id string `json:"id"`

	// InReplyToAccountId ID of the account that authored the status being replied to.
	InReplyToAccountId *string `json:"in_reply_to_account_id"`

	// InReplyToId ID of the status being replied to.
	InReplyToId *string `json:"in_reply_to_id"`

	// Language Primary language of this status.
	Language *string `json:"language"`

	// MediaAttachments Media that is attached to this status.
	MediaAttachments []MediaAttachment `json:"media_attachments"`

	// Mentions Mentions of users within the status content.
	Mentions []StatusMention `json:"mentions"`

	// Muted If the current token has an authorized user: Have you muted notifications for this status’s conversation?
	Muted *bool `json:"muted,omitempty"`

	// Pinned If the current token has an authorized user: Have you pinned this status? Only appears if the status is pinnable.
	Pinned *bool `json:"pinned,omitempty"`

	// Poll Represents a poll attached to a status.
	Poll Poll `json:"poll"`

	// Reblog The status being reblogged.
	Reblog map[string]interface{} `json:"reblog"`

	// Reblogged If the current token has an authorized user: Have you boosted this status?
	Reblogged *bool `json:"reblogged,omitempty"`

	// ReblogsCount How many boosts this status has received.
	ReblogsCount int `json:"reblogs_count"`

	// RepliesCount How many replies this status has received.
	RepliesCount int `json:"replies_count"`

	// Sensitive Is this status marked as sensitive content?
	Sensitive bool `json:"sensitive"`

	// SpoilerText Subject or summary line, below which status content is collapsed until expanded.
	SpoilerText string `json:"spoiler_text"`

	// Tags Hashtags used within the status content.
	Tags []StatusTag `json:"tags"`

	// Text Plain-text source of a status. Returned instead of content when status is deleted, so the user may redraft from the source text without the client having to reverse-engineer the original text from the HTML content.
	Text *string `json:"text"`

	// Uri URI of the status used for federation.
	Uri string `json:"uri"`

	// Url A link to the status’s HTML representation.
	Url *string `json:"url"`

	// Visibility Visibility of this status.
	Visibility StatusVisibility `json:"visibility"`
}

// StatusVisibility Visibility of this status.
type StatusVisibility string

// StatusMention defines model for StatusMention.
type StatusMention struct {
	// Acct The webfinger acct: URI of the mentioned user. Equivalent to username for local users, or username@domain for remote users.
	Acct string `json:"acct"`

	// Id The account ID of the mentioned user.
	Id string `json:"id"`

	// Url The location of the mentioned user’s profile.
	Url string `json:"url"`

	// Username The username of the mentioned user.
	Username string `json:"username"`
}

// StatusTag defines model for StatusTag.
type StatusTag struct {
	// Name The value of the hashtag after the # sign.
	Name string `json:"name"`

	// Url A link to the hashtag on the instance.
	Url string `json:"url"`
}

// ExcludeReblogsQueryParam defines model for ExcludeReblogsQueryParam.
type ExcludeReblogsQueryParam = bool

// ExcludeRepliesQueryParam defines model for ExcludeRepliesQueryParam.
type ExcludeRepliesQueryParam = bool

// LimitQueryParam defines model for LimitQueryParam.
type LimitQueryParam = int

// MaxIdQueryParam defines model for MaxIdQueryParam.
type MaxIdQueryParam = string

// MinIdQueryParam defines model for MinIdQueryParam.
type MinIdQueryParam = string

// OnlyMediaQueryParam defines model for OnlyMediaQueryParam.
type OnlyMediaQueryParam = bool

// PinnedQueryParam defines model for PinnedQueryParam.
type PinnedQueryParam = bool

// SinceIdQueryParam defines model for SinceIdQueryParam.
type SinceIdQueryParam = string

// TaggedQueryParam defines model for TaggedQueryParam.
type TaggedQueryParam = string

// GetApiV1AccountsUidStatusesParams defines parameters for GetApiV1AccountsUidStatuses.
type GetApiV1AccountsUidStatusesParams struct {
	// MaxId Return results older than this ID
	MaxId *MaxIdQueryParam `form:"max_id,omitempty" json:"max_id,omitempty"`

	// SinceId Return results newer than this ID
	SinceId *SinceIdQueryParam `form:"since_id,omitempty" json:"since_id,omitempty"`

	// MinId Return results immediately newer than this ID
	MinId *MinIdQueryParam `form:"min_id,omitempty" json:"min_id,omitempty"`

	// Limit Maximum number of results to return. Defaults to 20 statuses. Max 40 statuses.
	Limit *LimitQueryParam `form:"limit,omitempty" json:"limit,omitempty"`

	// OnlyMedia Filter out statuses without attachments.
	OnlyMedia *OnlyMediaQueryParam `form:"only_media,omitempty" json:"only_media,omitempty"`

	// ExcludeReplies Filter out statuses in reply to a different account.
	ExcludeReplies *ExcludeRepliesQueryParam `form:"exclude_replies,omitempty" json:"exclude_replies,omitempty"`

	// ExcludeReblogs Filter out boosts from the response.
	ExcludeReblogs *ExcludeReblogsQueryParam `form:"exclude_reblogs,omitempty" json:"exclude_reblogs,omitempty"`

	// Pinned Filter for pinned statuses only.
	Pinned *PinnedQueryParam `form:"pinned,omitempty" json:"pinned,omitempty"`

	// Tagged Filter for statuses using a specific hashtag.
	Tagged *TaggedQueryParam `form:"tagged,omitempty" json:"tagged,omitempty"`
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Verify account credentials
	// (GET /api/v1/accounts/verify_credentials)
	GetApiV1AccountsVerifyCredentials(ctx echo.Context) error
	// Get account
	// (GET /api/v1/accounts/{uid})
	GetApiV1AccountsUid(ctx echo.Context, uid string) error
	// Get account’s statuses
	// (GET /api/v1/accounts/{uid}/statuses)
	GetApiV1AccountsUidStatuses(ctx echo.Context, uid string, params GetApiV1AccountsUidStatusesParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// GetApiV1AccountsVerifyCredentials converts echo context to params.
func (w *ServerInterfaceWrapper) GetApiV1AccountsVerifyCredentials(ctx echo.Context) error {
	var err error

	ctx.Set(NPubOrNSecScopes, []string{})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApiV1AccountsVerifyCredentials(ctx)
	return err
}

// GetApiV1AccountsUid converts echo context to params.
func (w *ServerInterfaceWrapper) GetApiV1AccountsUid(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "uid" -------------
	var uid string

	err = runtime.BindStyledParameterWithLocation("simple", false, "uid", runtime.ParamLocationPath, ctx.Param("uid"), &uid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter uid: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApiV1AccountsUid(ctx, uid)
	return err
}

// GetApiV1AccountsUidStatuses converts echo context to params.
func (w *ServerInterfaceWrapper) GetApiV1AccountsUidStatuses(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "uid" -------------
	var uid string

	err = runtime.BindStyledParameterWithLocation("simple", false, "uid", runtime.ParamLocationPath, ctx.Param("uid"), &uid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter uid: %s", err))
	}

	ctx.Set(NPubOrNSecScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApiV1AccountsUidStatusesParams
	// ------------- Optional query parameter "max_id" -------------

	err = runtime.BindQueryParameter("form", true, false, "max_id", ctx.QueryParams(), &params.MaxId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max_id: %s", err))
	}

	// ------------- Optional query parameter "since_id" -------------

	err = runtime.BindQueryParameter("form", true, false, "since_id", ctx.QueryParams(), &params.SinceId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter since_id: %s", err))
	}

	// ------------- Optional query parameter "min_id" -------------

	err = runtime.BindQueryParameter("form", true, false, "min_id", ctx.QueryParams(), &params.MinId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min_id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "only_media" -------------

	err = runtime.BindQueryParameter("form", true, false, "only_media", ctx.QueryParams(), &params.OnlyMedia)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter only_media: %s", err))
	}

	// ------------- Optional query parameter "exclude_replies" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude_replies", ctx.QueryParams(), &params.ExcludeReplies)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude_replies: %s", err))
	}

	// ------------- Optional query parameter "exclude_reblogs" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude_reblogs", ctx.QueryParams(), &params.ExcludeReblogs)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude_reblogs: %s", err))
	}

	// ------------- Optional query parameter "pinned" -------------

	err = runtime.BindQueryParameter("form", true, false, "pinned", ctx.QueryParams(), &params.Pinned)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter pinned: %s", err))
	}

	// ------------- Optional query parameter "tagged" -------------

	err = runtime.BindQueryParameter("form", true, false, "tagged", ctx.QueryParams(), &params.Tagged)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tagged: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApiV1AccountsUidStatuses(ctx, uid, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/api/v1/accounts/verify_credentials", wrapper.GetApiV1AccountsVerifyCredentials)
	router.GET(baseURL+"/api/v1/accounts/:uid", wrapper.GetApiV1AccountsUid)
	router.GET(baseURL+"/api/v1/accounts/:uid/statuses", wrapper.GetApiV1AccountsUidStatuses)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
