// Package mopenapi provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.13.0 DO NOT EDIT.
package mopenapi

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

const (
	NPubOrNSecScopes = "NPubOrNSec.Scopes"
)

// Defines values for FilterContext.
const (
	FilterContextAccount       FilterContext = "account"
	FilterContextHome          FilterContext = "home"
	FilterContextNotifications FilterContext = "notifications"
	FilterContextPublic        FilterContext = "public"
	FilterContextThread        FilterContext = "thread"
)

// Defines values for FilterFilterAction.
const (
	Hide FilterFilterAction = "hide"
	Warn FilterFilterAction = "warn"
)

// Defines values for MediaAttachmentType.
const (
	MediaAttachmentTypeAudio   MediaAttachmentType = "audio"
	MediaAttachmentTypeGif     MediaAttachmentType = "gif"
	MediaAttachmentTypeImage   MediaAttachmentType = "image"
	MediaAttachmentTypeUnknown MediaAttachmentType = "unknown"
	MediaAttachmentTypeVideo   MediaAttachmentType = "video"
)

// Defines values for PreviewCardType.
const (
	PreviewCardTypeLink  PreviewCardType = "link"
	PreviewCardTypePhoto PreviewCardType = "photo"
	PreviewCardTypeRich  PreviewCardType = "rich"
	PreviewCardTypeVideo PreviewCardType = "video"
)

// Defines values for SourcePrivacy.
const (
	SourcePrivacyDirect   SourcePrivacy = "direct"
	SourcePrivacyPrivate  SourcePrivacy = "private"
	SourcePrivacyPublic   SourcePrivacy = "public"
	SourcePrivacyUnlisted SourcePrivacy = "unlisted"
)

// Defines values for StatusVisibility.
const (
	StatusVisibilityDirect   StatusVisibility = "direct"
	StatusVisibilityPrivate  StatusVisibility = "private"
	StatusVisibilityPublic   StatusVisibility = "public"
	StatusVisibilityUnlisted StatusVisibility = "unlisted"
)

// Defines values for StatusOrignVisibility.
const (
	StatusOrignVisibilityDirect   StatusOrignVisibility = "direct"
	StatusOrignVisibilityPrivate  StatusOrignVisibility = "private"
	StatusOrignVisibilityPublic   StatusOrignVisibility = "public"
	StatusOrignVisibilityUnlisted StatusOrignVisibility = "unlisted"
)

// Defines values for StatusReblogVisibility.
const (
	Direct   StatusReblogVisibility = "direct"
	Private  StatusReblogVisibility = "private"
	Public   StatusReblogVisibility = "public"
	Unlisted StatusReblogVisibility = "unlisted"
)

// Account defines model for Account.
type Account struct {
	// Acct The Webfinger account URI. Equal to username for local users, or username@domain for remote users.
	Acct string `json:"acct"`

	// Avatar An image icon that is shown next to statuses and in the profile. (URL)
	Avatar string `json:"avatar"`

	// AvatarStatic A static version of the avatar. Equal to avatar if its value is a static image; different if avatar is an animated GIF.
	AvatarStatic string `json:"avatar_static"`

	// Bot Indicates that the account may perform automated actions, may not be monitored, or identifies
	Bot bool `json:"bot"`

	// CreatedAt When the account was created. (ISO 8601)
	CreatedAt string `json:"created_at"`

	// Discoverable Whether the account has opted into discovery features such as the profile directory.
	Discoverable *bool `json:"discoverable"`

	// DisplayName The profile’s display name.
	DisplayName string `json:"display_name"`

	// Emojis Custom emoji entities to be used when rendering the profile.
	Emojis []CustomEmoji `json:"emojis"`

	// Fields Custom emoji entities to be used when rendering the profile.
	Fields []Field `json:"fields"`

	// FollowersCount The reported followers of this profile.
	FollowersCount int `json:"followers_count"`

	// FollowingCount The reported follows of this profile.
	FollowingCount int `json:"following_count"`

	// Group Indicates that the account represents a Group actor.
	Group bool `json:"group"`

	// Header An image banner that is shown above the profile and in profile cards.
	Header string `json:"header"`

	// HeaderStatic A static version of the header. Equal to header if its value is a static image; different if header is an animated GIF.
	HeaderStatic string `json:"header_static"`

	// Id The account id.
	Id string `json:"id"`

	// LastStatusAt When the most recent status was posted. (ISO 8601)
	LastStatusAt *string `json:"last_status_at"`

	// Limited An extra attribute returned only when an account is silenced. If true, indicates that the account should be hidden behind a warning screen.
	Limited *bool `json:"limited,omitempty"`

	// Locked Whether the account manually approves follow requests.
	Locked bool `json:"locked"`

	// Moved Indicates that the profile is currently inactive and that its user has moved to a new account.
	Moved *bool `json:"moved"`

	// Noindex Whether the local user has opted out of being indexed by search engines.
	Noindex *bool `json:"noindex"`

	// Note The profile’s bio or description. (HTML)
	Note string `json:"note"`

	// StatusesCount How many statuses are attached to this account.
	StatusesCount int `json:"statuses_count"`

	// Suspended An extra attribute returned only when an account is suspended.
	Suspended *bool `json:"suspended,omitempty"`

	// Url The location of the user’s profile page.
	Url string `json:"url"`

	// Username The username of the account, not including domain.
	Username string `json:"username"`
}

// Application defines model for Application.
type Application struct {
	Name    *string `json:"name"`
	Website *string `json:"website"`
}

// CredentialAccount defines model for CredentialAccount.
type CredentialAccount struct {
	// Acct The Webfinger account URI. Equal to username for local users, or username@domain for remote users.
	Acct string `json:"acct"`

	// Avatar An image icon that is shown next to statuses and in the profile. (URL)
	Avatar string `json:"avatar"`

	// AvatarStatic A static version of the avatar. Equal to avatar if its value is a static image; different if avatar is an animated GIF.
	AvatarStatic string `json:"avatar_static"`

	// Bot Indicates that the account may perform automated actions, may not be monitored, or identifies
	Bot bool `json:"bot"`

	// CreatedAt When the account was created. (ISO 8601)
	CreatedAt string `json:"created_at"`

	// Discoverable Whether the account has opted into discovery features such as the profile directory.
	Discoverable *bool `json:"discoverable"`

	// DisplayName The profile’s display name.
	DisplayName string `json:"display_name"`

	// Emojis Custom emoji entities to be used when rendering the profile.
	Emojis []CustomEmoji `json:"emojis"`

	// Fields Custom emoji entities to be used when rendering the profile.
	Fields []Field `json:"fields"`

	// FollowersCount The reported followers of this profile.
	FollowersCount int `json:"followers_count"`

	// FollowingCount The reported follows of this profile.
	FollowingCount int `json:"following_count"`

	// Group Indicates that the account represents a Group actor.
	Group bool `json:"group"`

	// Header An image banner that is shown above the profile and in profile cards.
	Header string `json:"header"`

	// HeaderStatic A static version of the header. Equal to header if its value is a static image; different if header is an animated GIF.
	HeaderStatic string `json:"header_static"`

	// Id The account id.
	Id string `json:"id"`

	// LastStatusAt When the most recent status was posted. (ISO 8601)
	LastStatusAt *string `json:"last_status_at"`

	// Limited An extra attribute returned only when an account is silenced. If true, indicates that the account should be hidden behind a warning screen.
	Limited *bool `json:"limited,omitempty"`

	// Locked Whether the account manually approves follow requests.
	Locked bool `json:"locked"`

	// Moved Indicates that the profile is currently inactive and that its user has moved to a new account.
	Moved *bool `json:"moved"`

	// Noindex Whether the local user has opted out of being indexed by search engines.
	Noindex *bool `json:"noindex"`

	// Note The profile’s bio or description. (HTML)
	Note   string `json:"note"`
	Role   Role   `json:"role"`
	Source Source `json:"source"`

	// StatusesCount How many statuses are attached to this account.
	StatusesCount int `json:"statuses_count"`

	// Suspended An extra attribute returned only when an account is suspended.
	Suspended *bool `json:"suspended,omitempty"`

	// Url The location of the user’s profile page.
	Url string `json:"url"`

	// Username The username of the account, not including domain.
	Username string `json:"username"`
}

// CustomEmoji defines model for CustomEmoji.
type CustomEmoji struct {
	// Category Used for sorting custom emoji in the picker.
	Category string `json:"category"`

	// Shortcode The name of the custom emoji.
	Shortcode string `json:"shortcode"`

	// StaticUrl A link to a static copy of the custom emoji.
	StaticUrl string `json:"static_url"`

	// Url A link to the custom emoji.
	Url string `json:"url"`

	// VisibleInPicker Whether this Emoji should be visible in the picker or unlisted.
	VisibleInPicker bool `json:"visible_in_picker"`
}

// Field defines model for Field.
type Field struct {
	// Name The key of a given field’s key-value pair.
	Name string `json:"name"`

	// Value The value associated with the name key.
	Value string `json:"value"`

	// VerifiedAt Timestamp of when the server verified a URL value for a rel=“me” link.
	VerifiedAt *string `json:"verified_at"`
}

// Filter Represents a user-defined filter for determining which statuses should not be shown to the user.
type Filter struct {
	// Context The contexts in which the filter should be applied.
	Context []FilterContext `json:"context"`

	// ExpiresAt When the filter should no longer be applied.
	ExpiresAt *string `json:"expires_at"`

	// FilterAction The action to be taken when a status matches this filter.
	FilterAction FilterFilterAction `json:"filter_action"`

	// Id The ID of the Filter in the database.
	Id string `json:"id"`

	// Keywords The keywords grouped under this filter.
	Keywords []FilterKeyword `json:"keywords"`

	// Statuses The statuses grouped under this filter.
	Statuses []FilterStatus `json:"statuses"`

	// Title A title given by the user to name the filter.
	Title string `json:"title"`
}

// FilterContext defines model for Filter.Context.
type FilterContext string

// FilterFilterAction The action to be taken when a status matches this filter.
type FilterFilterAction string

// FilterKeyword Represents a keyword that, if matched, should cause the filter action to be taken.
type FilterKeyword struct {
	// Id The ID of the FilterKeyword in the database.
	Id string `json:"id"`

	// Keyword The phrase to be matched against.
	Keyword string `json:"keyword"`

	// WholeWord Should the filter consider word boundaries? See implementation guidelines for filters.
	WholeWord bool `json:"whole_word"`
}

// FilterResult Represents a filter whose keywords matched a given status.
type FilterResult struct {
	// Filter Represents a user-defined filter for determining which statuses should not be shown to the user.
	Filter Filter `json:"filter"`

	// KeywordMatches The keyword within the filter that was matched.
	KeywordMatches *[]string `json:"keyword_matches"`

	// StatusMatches The status ID within the filter that was matched.
	StatusMatches *[]string `json:"status_matches"`
}

// FilterStatus Represents a status ID that, if matched, should cause the filter action to be taken.
type FilterStatus struct {
	// Id The ID of the FilterStatus in the database.
	Id string `json:"id"`

	// StatusId The ID of the Status that will be filtered.
	StatusId string `json:"status_id"`
}

// MediaAttachment defines model for MediaAttachment.
type MediaAttachment struct {
	// Blurhash A hash computed by the BlurHash algorithm, for generating colorful preview thumbnails when media has not been downloaded yet.
	Blurhash string `json:"blurhash"`

	// Description Alternate text that describes what is in the media attachment, to be used for the visually impaired or when media attachments do not load.
	Description string `json:"description"`

	// Id The ID of the attachment in the database.
	Id   string         `json:"id"`
	Meta MediaImegeMeta `json:"meta"`

	// PreviewUrl The location of a scaled-down preview of the attachment.
	PreviewUrl string `json:"preview_url"`

	// RemoteUrl The location of the full-size original attachment on the remote website.
	RemoteUrl *string `json:"remote_url"`

	// Type The type of the attachment.
	Type MediaAttachmentType `json:"type"`

	// Url The location of the original full-size attachment.
	Url string `json:"url"`
}

// MediaAttachmentType The type of the attachment.
type MediaAttachmentType string

// MediaImageForcus defines model for MediaImageForcus.
type MediaImageForcus struct {
	X *float32 `json:"x,omitempty"`
	Y *float32 `json:"y,omitempty"`
}

// MediaImageSize defines model for MediaImageSize.
type MediaImageSize struct {
	Aspect *float32 `json:"aspect,omitempty"`
	Height *int     `json:"height,omitempty"`
	Size   *string  `json:"size,omitempty"`
	Width  *int     `json:"width,omitempty"`
}

// MediaImegeMeta defines model for MediaImegeMeta.
type MediaImegeMeta struct {
	Focus    *MediaImageForcus `json:"focus,omitempty"`
	Original *MediaImageSize   `json:"original,omitempty"`
	Small    *MediaImageSize   `json:"small,omitempty"`
}

// Poll Represents a poll attached to a status.
type Poll struct {
	// Emojis Custom emoji to be used for rendering poll options.
	Emojis []CustomEmoji `json:"emojis"`

	// Expired Is the poll currently expired?
	Expired bool `json:"expired"`

	// ExpiresAt When the poll ends.
	ExpiresAt *string `json:"expires_at"`

	// Id The ID of the poll in the database.
	Id string `json:"id"`

	// Multiple Does the poll allow multiple-choice answers?
	Multiple bool `json:"multiple"`

	// Options Possible answers for the poll.
	Options []PollOption `json:"options"`

	// OwnVotes When called with a user token, which options has the authorized user chosen? Contains an array of index values for options.
	OwnVotes *[]int `json:"own_votes,omitempty"`

	// Voted When called with a user token, has the authorized user voted?
	Voted *bool `json:"voted,omitempty"`

	// VotersCount How many unique accounts have voted on a multiple-choice poll.
	VotersCount *int `json:"voters_count"`

	// VotesCount How many votes have been received.
	VotesCount int `json:"votes_count"`
}

// PollOption defines model for PollOption.
type PollOption struct {
	// Title The text value of the poll option.
	Title string `json:"title"`

	// VotesCount The total number of received votes for this option.
	VotesCount *int `json:"votes_count"`
}

// PreviewCard Represents a rich preview card that is generated using OpenGraph tags from a URL.
type PreviewCard struct {
	// AuthorName The author of the original resource.
	AuthorName string `json:"author_name"`

	// AuthorUrl A link to the author of the original resource.
	AuthorUrl string `json:"author_url"`

	// Blurhash A hash computed by the BlurHash algorithm, for generating colorful preview thumbnails when media has not been downloaded yet.
	Blurhash *string `json:"blurhash"`

	// Description Description of preview.
	Description string `json:"description"`

	// EmbedUrl Used for photo embeds, instead of custom html.
	EmbedUrl string `json:"embed_url"`

	// Height Height of preview, in pixels.
	Height int `json:"height"`

	// Html HTML to be used for generating the preview card.
	Html string `json:"html"`

	// Image Preview thumbnail.
	Image *string `json:"image"`

	// ProviderName The provider of the original resource.
	ProviderName string `json:"provider_name"`

	// ProviderUrl A link to the provider of the original resource.
	ProviderUrl string `json:"provider_url"`

	// Title Title of linked resource.
	Title string `json:"title"`

	// Type The type of the preview card.
	Type PreviewCardType `json:"type"`

	// Url Location of linked resource.
	Url string `json:"url"`

	// Width Width of preview, in pixels.
	Width int `json:"width"`
}

// PreviewCardType The type of the preview card.
type PreviewCardType string

// Role defines model for Role.
type Role struct {
	// Color The hex code assigned to this role. If no hex code is assigned, the string will be empty.
	Color string `json:"color"`

	// Highlighted  Whether the role is publicly visible as a badge on user profiles.
	Highlighted bool `json:"highlighted"`

	// Id The ID of the Role in the database.
	Id int `json:"id"`

	// Name The name of the role.
	Name string `json:"name"`

	// Permissions A bitmask that represents the sum of all permissions granted to the role.
	Permissions int `json:"permissions"`
}

// Source defines model for Source.
type Source struct {
	// Fields Metadata about the account.
	Fields []Field `json:"fields"`

	// FollowRequestsCount The number of pending follow requests.
	FollowRequestsCount int `json:"follow_requests_count"`

	// Language The default posting language for new statuses. (ISO 639-1 language two-letter code) or empty string.
	Language string `json:"language"`

	// Note Profile bio, in plain-text instead of in HTML.
	Note string `json:"note"`

	// Privacy The default post privacy to be used for new statuses.
	Privacy SourcePrivacy `json:"privacy"`

	// Sensitive Whether new statuses should be marked sensitive by default.
	Sensitive bool `json:"sensitive"`
}

// SourcePrivacy The default post privacy to be used for new statuses.
type SourcePrivacy string

// Status defines model for Status.
type Status struct {
	Account     Account      `json:"account"`
	Application *Application `json:"application,omitempty"`

	// Bookmarked If the current token has an authorized user: Have you bookmarked this status?
	Bookmarked *bool       `json:"bookmarked,omitempty"`
	Card       Status_Card `json:"card"`

	// Content HTML-encoded status content.
	Content string `json:"content"`

	// CreatedAt The date when this status was created.
	CreatedAt string `json:"created_at"`

	// EditedAt Timestamp of when the status was last edited.
	EditedAt *string `json:"edited_at"`

	// Emojis Custom emoji to be used when rendering status content.
	Emojis []CustomEmoji `json:"emojis"`

	// Favourited If the current token has an authorized user: Have you favourited this status?
	Favourited *bool `json:"favourited,omitempty"`

	// FavouritesCount How many favourites this status has received.
	FavouritesCount int `json:"favourites_count"`

	// Filtered If the current token has an authorized user: The filter and keywords that matched this status.
	Filtered *[]FilterResult `json:"filtered,omitempty"`

	// Id ID of the status in the database.
	Id string `json:"id"`

	// InReplyToAccountId ID of the account that authored the status being replied to.
	InReplyToAccountId *string `json:"in_reply_to_account_id"`

	// InReplyToId ID of the status being replied to.
	InReplyToId *string `json:"in_reply_to_id"`

	// Language Primary language of this status.
	Language *string `json:"language"`

	// MediaAttachments Media that is attached to this status.
	MediaAttachments []MediaAttachment `json:"media_attachments"`

	// Mentions Mentions of users within the status content.
	Mentions []StatusMention `json:"mentions"`

	// Muted If the current token has an authorized user: Have you muted notifications for this status’s conversation?
	Muted *bool `json:"muted,omitempty"`

	// Pinned If the current token has an authorized user: Have you pinned this status? Only appears if the status is pinnable.
	Pinned *bool       `json:"pinned,omitempty"`
	Poll   Status_Poll `json:"poll"`

	// Reblog The status being reblogged.
	Reblog Status_Reblog `json:"reblog"`

	// Reblogged If the current token has an authorized user: Have you boosted this status?
	Reblogged *bool `json:"reblogged,omitempty"`

	// ReblogsCount How many boosts this status has received.
	ReblogsCount int `json:"reblogs_count"`

	// RepliesCount How many replies this status has received.
	RepliesCount int `json:"replies_count"`

	// Sensitive Is this status marked as sensitive content?
	Sensitive bool `json:"sensitive"`

	// SpoilerText Subject or summary line, below which status content is collapsed until expanded.
	SpoilerText string `json:"spoiler_text"`

	// Tags Hashtags used within the status content.
	Tags []StatusTag `json:"tags"`

	// Text Plain-text source of a status. Returned instead of content when status is deleted, so the user may redraft from the source text without the client having to reverse-engineer the original text from the HTML content.
	Text *string `json:"text"`

	// Uri URI of the status used for federation.
	Uri string `json:"uri"`

	// Url A link to the status’s HTML representation.
	Url *string `json:"url"`

	// Visibility Visibility of this status.
	Visibility StatusVisibility `json:"visibility"`
}

// StatusCard1 defines model for .
type StatusCard1 = map[string]interface{}

// Status_Card defines model for Status.Card.
type Status_Card struct {
	union json.RawMessage
}

// StatusPoll1 defines model for .
type StatusPoll1 = map[string]interface{}

// Status_Poll defines model for Status.Poll.
type Status_Poll struct {
	union json.RawMessage
}

// StatusReblog1 defines model for .
type StatusReblog1 = map[string]interface{}

// Status_Reblog The status being reblogged.
type Status_Reblog struct {
	union json.RawMessage
}

// StatusVisibility Visibility of this status.
type StatusVisibility string

// StatusMention defines model for StatusMention.
type StatusMention struct {
	// Acct The webfinger acct: URI of the mentioned user. Equivalent to username for local users, or username@domain for remote users.
	Acct string `json:"acct"`

	// Id The account ID of the mentioned user.
	Id string `json:"id"`

	// Url The location of the mentioned user’s profile.
	Url string `json:"url"`

	// Username The username of the mentioned user.
	Username string `json:"username"`
}

// StatusOrign Represents a status posted by an account.
type StatusOrign struct {
	Account     Account      `json:"account"`
	Application *Application `json:"application,omitempty"`

	// Bookmarked If the current token has an authorized user: Have you bookmarked this status?
	Bookmarked *bool            `json:"bookmarked,omitempty"`
	Card       StatusOrign_Card `json:"card"`

	// Content HTML-encoded status content.
	Content string `json:"content"`

	// CreatedAt The date when this status was created.
	CreatedAt string `json:"created_at"`

	// EditedAt Timestamp of when the status was last edited.
	EditedAt *string `json:"edited_at"`

	// Emojis Custom emoji to be used when rendering status content.
	Emojis []CustomEmoji `json:"emojis"`

	// Favourited If the current token has an authorized user: Have you favourited this status?
	Favourited *bool `json:"favourited,omitempty"`

	// FavouritesCount How many favourites this status has received.
	FavouritesCount int `json:"favourites_count"`

	// Filtered If the current token has an authorized user: The filter and keywords that matched this status.
	Filtered *[]FilterResult `json:"filtered,omitempty"`

	// Id ID of the status in the database.
	Id string `json:"id"`

	// InReplyToAccountId ID of the account that authored the status being replied to.
	InReplyToAccountId *string `json:"in_reply_to_account_id"`

	// InReplyToId ID of the status being replied to.
	InReplyToId *string `json:"in_reply_to_id"`

	// Language Primary language of this status.
	Language *string `json:"language"`

	// MediaAttachments Media that is attached to this status.
	MediaAttachments []MediaAttachment `json:"media_attachments"`

	// Mentions Mentions of users within the status content.
	Mentions []StatusMention `json:"mentions"`

	// Muted If the current token has an authorized user: Have you muted notifications for this status’s conversation?
	Muted *bool `json:"muted,omitempty"`

	// Pinned If the current token has an authorized user: Have you pinned this status? Only appears if the status is pinnable.
	Pinned *bool            `json:"pinned,omitempty"`
	Poll   StatusOrign_Poll `json:"poll"`

	// Reblogged If the current token has an authorized user: Have you boosted this status?
	Reblogged *bool `json:"reblogged,omitempty"`

	// ReblogsCount How many boosts this status has received.
	ReblogsCount int `json:"reblogs_count"`

	// RepliesCount How many replies this status has received.
	RepliesCount int `json:"replies_count"`

	// Sensitive Is this status marked as sensitive content?
	Sensitive bool `json:"sensitive"`

	// SpoilerText Subject or summary line, below which status content is collapsed until expanded.
	SpoilerText string `json:"spoiler_text"`

	// Tags Hashtags used within the status content.
	Tags []StatusTag `json:"tags"`

	// Text Plain-text source of a status. Returned instead of content when status is deleted, so the user may redraft from the source text without the client having to reverse-engineer the original text from the HTML content.
	Text *string `json:"text"`

	// Uri URI of the status used for federation.
	Uri string `json:"uri"`

	// Url A link to the status’s HTML representation.
	Url *string `json:"url"`

	// Visibility Visibility of this status.
	Visibility StatusOrignVisibility `json:"visibility"`
}

// StatusOrignCard1 defines model for .
type StatusOrignCard1 = map[string]interface{}

// StatusOrign_Card defines model for StatusOrign.Card.
type StatusOrign_Card struct {
	union json.RawMessage
}

// StatusOrignPoll1 defines model for .
type StatusOrignPoll1 = map[string]interface{}

// StatusOrign_Poll defines model for StatusOrign.Poll.
type StatusOrign_Poll struct {
	union json.RawMessage
}

// StatusOrignVisibility Visibility of this status.
type StatusOrignVisibility string

// StatusReblog defines model for StatusReblog.
type StatusReblog struct {
	Account     Account      `json:"account"`
	Application *Application `json:"application,omitempty"`

	// Bookmarked If the current token has an authorized user: Have you bookmarked this status?
	Bookmarked *bool             `json:"bookmarked,omitempty"`
	Card       StatusReblog_Card `json:"card"`

	// Content HTML-encoded status content.
	Content string `json:"content"`

	// CreatedAt The date when this status was created.
	CreatedAt string `json:"created_at"`

	// EditedAt Timestamp of when the status was last edited.
	EditedAt *string `json:"edited_at"`

	// Emojis Custom emoji to be used when rendering status content.
	Emojis []CustomEmoji `json:"emojis"`

	// Favourited If the current token has an authorized user: Have you favourited this status?
	Favourited *bool `json:"favourited,omitempty"`

	// FavouritesCount How many favourites this status has received.
	FavouritesCount int `json:"favourites_count"`

	// Filtered If the current token has an authorized user: The filter and keywords that matched this status.
	Filtered *[]FilterResult `json:"filtered,omitempty"`

	// Id ID of the status in the database.
	Id string `json:"id"`

	// InReplyToAccountId ID of the account that authored the status being replied to.
	InReplyToAccountId *string `json:"in_reply_to_account_id"`

	// InReplyToId ID of the status being replied to.
	InReplyToId *string `json:"in_reply_to_id"`

	// Language Primary language of this status.
	Language *string `json:"language"`

	// MediaAttachments Media that is attached to this status.
	MediaAttachments []MediaAttachment `json:"media_attachments"`

	// Mentions Mentions of users within the status content.
	Mentions []StatusMention `json:"mentions"`

	// Muted If the current token has an authorized user: Have you muted notifications for this status’s conversation?
	Muted *bool `json:"muted,omitempty"`

	// Pinned If the current token has an authorized user: Have you pinned this status? Only appears if the status is pinnable.
	Pinned *bool                   `json:"pinned,omitempty"`
	Poll   StatusReblog_Poll       `json:"poll"`
	Reblog *map[string]interface{} `json:"reblog"`

	// Reblogged If the current token has an authorized user: Have you boosted this status?
	Reblogged *bool `json:"reblogged,omitempty"`

	// ReblogsCount How many boosts this status has received.
	ReblogsCount int `json:"reblogs_count"`

	// RepliesCount How many replies this status has received.
	RepliesCount int `json:"replies_count"`

	// Sensitive Is this status marked as sensitive content?
	Sensitive bool `json:"sensitive"`

	// SpoilerText Subject or summary line, below which status content is collapsed until expanded.
	SpoilerText string `json:"spoiler_text"`

	// Tags Hashtags used within the status content.
	Tags []StatusTag `json:"tags"`

	// Text Plain-text source of a status. Returned instead of content when status is deleted, so the user may redraft from the source text without the client having to reverse-engineer the original text from the HTML content.
	Text *string `json:"text"`

	// Uri URI of the status used for federation.
	Uri string `json:"uri"`

	// Url A link to the status’s HTML representation.
	Url *string `json:"url"`

	// Visibility Visibility of this status.
	Visibility StatusReblogVisibility `json:"visibility"`
}

// StatusReblogCard1 defines model for .
type StatusReblogCard1 = map[string]interface{}

// StatusReblog_Card defines model for StatusReblog.Card.
type StatusReblog_Card struct {
	union json.RawMessage
}

// StatusReblogPoll1 defines model for .
type StatusReblogPoll1 = map[string]interface{}

// StatusReblog_Poll defines model for StatusReblog.Poll.
type StatusReblog_Poll struct {
	union json.RawMessage
}

// StatusReblogVisibility Visibility of this status.
type StatusReblogVisibility string

// StatusTag defines model for StatusTag.
type StatusTag struct {
	// Name The value of the hashtag after the # sign.
	Name string `json:"name"`

	// Url A link to the hashtag on the instance.
	Url string `json:"url"`
}

// ExcludeReblogsQueryParam defines model for ExcludeReblogsQueryParam.
type ExcludeReblogsQueryParam = bool

// ExcludeRepliesQueryParam defines model for ExcludeRepliesQueryParam.
type ExcludeRepliesQueryParam = bool

// LimitQueryParam defines model for LimitQueryParam.
type LimitQueryParam = int

// MaxIdQueryParam defines model for MaxIdQueryParam.
type MaxIdQueryParam = string

// MinIdQueryParam defines model for MinIdQueryParam.
type MinIdQueryParam = string

// OnlyMediaQueryParam defines model for OnlyMediaQueryParam.
type OnlyMediaQueryParam = bool

// PinnedQueryParam defines model for PinnedQueryParam.
type PinnedQueryParam = bool

// SinceIdQueryParam defines model for SinceIdQueryParam.
type SinceIdQueryParam = string

// TaggedQueryParam defines model for TaggedQueryParam.
type TaggedQueryParam = string

// GetApiV1AccountsUidStatusesParams defines parameters for GetApiV1AccountsUidStatuses.
type GetApiV1AccountsUidStatusesParams struct {
	// MaxId Return results older than this ID
	MaxId *MaxIdQueryParam `form:"max_id,omitempty" json:"max_id,omitempty"`

	// SinceId Return results newer than this ID
	SinceId *SinceIdQueryParam `form:"since_id,omitempty" json:"since_id,omitempty"`

	// MinId Return results immediately newer than this ID
	MinId *MinIdQueryParam `form:"min_id,omitempty" json:"min_id,omitempty"`

	// Limit Maximum number of results to return. Defaults to 20 statuses. Max 40 statuses.
	Limit *LimitQueryParam `form:"limit,omitempty" json:"limit,omitempty"`

	// OnlyMedia Filter out statuses without attachments.
	OnlyMedia *OnlyMediaQueryParam `form:"only_media,omitempty" json:"only_media,omitempty"`

	// ExcludeReplies Filter out statuses in reply to a different account.
	ExcludeReplies *ExcludeRepliesQueryParam `form:"exclude_replies,omitempty" json:"exclude_replies,omitempty"`

	// ExcludeReblogs Filter out boosts from the response.
	ExcludeReblogs *ExcludeReblogsQueryParam `form:"exclude_reblogs,omitempty" json:"exclude_reblogs,omitempty"`

	// Pinned Filter for pinned statuses only.
	Pinned *PinnedQueryParam `form:"pinned,omitempty" json:"pinned,omitempty"`

	// Tagged Filter for statuses using a specific hashtag.
	Tagged *TaggedQueryParam `form:"tagged,omitempty" json:"tagged,omitempty"`
}

// AsPreviewCard returns the union data inside the Status_Card as a PreviewCard
func (t Status_Card) AsPreviewCard() (PreviewCard, error) {
	var body PreviewCard
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPreviewCard overwrites any union data inside the Status_Card as the provided PreviewCard
func (t *Status_Card) FromPreviewCard(v PreviewCard) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePreviewCard performs a merge with any union data inside the Status_Card, using the provided PreviewCard
func (t *Status_Card) MergePreviewCard(v PreviewCard) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsStatusCard1 returns the union data inside the Status_Card as a StatusCard1
func (t Status_Card) AsStatusCard1() (StatusCard1, error) {
	var body StatusCard1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStatusCard1 overwrites any union data inside the Status_Card as the provided StatusCard1
func (t *Status_Card) FromStatusCard1(v StatusCard1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStatusCard1 performs a merge with any union data inside the Status_Card, using the provided StatusCard1
func (t *Status_Card) MergeStatusCard1(v StatusCard1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t Status_Card) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Status_Card) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsPoll returns the union data inside the Status_Poll as a Poll
func (t Status_Poll) AsPoll() (Poll, error) {
	var body Poll
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPoll overwrites any union data inside the Status_Poll as the provided Poll
func (t *Status_Poll) FromPoll(v Poll) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePoll performs a merge with any union data inside the Status_Poll, using the provided Poll
func (t *Status_Poll) MergePoll(v Poll) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsStatusPoll1 returns the union data inside the Status_Poll as a StatusPoll1
func (t Status_Poll) AsStatusPoll1() (StatusPoll1, error) {
	var body StatusPoll1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStatusPoll1 overwrites any union data inside the Status_Poll as the provided StatusPoll1
func (t *Status_Poll) FromStatusPoll1(v StatusPoll1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStatusPoll1 performs a merge with any union data inside the Status_Poll, using the provided StatusPoll1
func (t *Status_Poll) MergeStatusPoll1(v StatusPoll1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t Status_Poll) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Status_Poll) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsStatusReblog returns the union data inside the Status_Reblog as a StatusReblog
func (t Status_Reblog) AsStatusReblog() (StatusReblog, error) {
	var body StatusReblog
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStatusReblog overwrites any union data inside the Status_Reblog as the provided StatusReblog
func (t *Status_Reblog) FromStatusReblog(v StatusReblog) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStatusReblog performs a merge with any union data inside the Status_Reblog, using the provided StatusReblog
func (t *Status_Reblog) MergeStatusReblog(v StatusReblog) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsStatusReblog1 returns the union data inside the Status_Reblog as a StatusReblog1
func (t Status_Reblog) AsStatusReblog1() (StatusReblog1, error) {
	var body StatusReblog1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStatusReblog1 overwrites any union data inside the Status_Reblog as the provided StatusReblog1
func (t *Status_Reblog) FromStatusReblog1(v StatusReblog1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStatusReblog1 performs a merge with any union data inside the Status_Reblog, using the provided StatusReblog1
func (t *Status_Reblog) MergeStatusReblog1(v StatusReblog1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t Status_Reblog) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Status_Reblog) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsPreviewCard returns the union data inside the StatusOrign_Card as a PreviewCard
func (t StatusOrign_Card) AsPreviewCard() (PreviewCard, error) {
	var body PreviewCard
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPreviewCard overwrites any union data inside the StatusOrign_Card as the provided PreviewCard
func (t *StatusOrign_Card) FromPreviewCard(v PreviewCard) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePreviewCard performs a merge with any union data inside the StatusOrign_Card, using the provided PreviewCard
func (t *StatusOrign_Card) MergePreviewCard(v PreviewCard) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsStatusOrignCard1 returns the union data inside the StatusOrign_Card as a StatusOrignCard1
func (t StatusOrign_Card) AsStatusOrignCard1() (StatusOrignCard1, error) {
	var body StatusOrignCard1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStatusOrignCard1 overwrites any union data inside the StatusOrign_Card as the provided StatusOrignCard1
func (t *StatusOrign_Card) FromStatusOrignCard1(v StatusOrignCard1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStatusOrignCard1 performs a merge with any union data inside the StatusOrign_Card, using the provided StatusOrignCard1
func (t *StatusOrign_Card) MergeStatusOrignCard1(v StatusOrignCard1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t StatusOrign_Card) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *StatusOrign_Card) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsPoll returns the union data inside the StatusOrign_Poll as a Poll
func (t StatusOrign_Poll) AsPoll() (Poll, error) {
	var body Poll
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPoll overwrites any union data inside the StatusOrign_Poll as the provided Poll
func (t *StatusOrign_Poll) FromPoll(v Poll) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePoll performs a merge with any union data inside the StatusOrign_Poll, using the provided Poll
func (t *StatusOrign_Poll) MergePoll(v Poll) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsStatusOrignPoll1 returns the union data inside the StatusOrign_Poll as a StatusOrignPoll1
func (t StatusOrign_Poll) AsStatusOrignPoll1() (StatusOrignPoll1, error) {
	var body StatusOrignPoll1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStatusOrignPoll1 overwrites any union data inside the StatusOrign_Poll as the provided StatusOrignPoll1
func (t *StatusOrign_Poll) FromStatusOrignPoll1(v StatusOrignPoll1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStatusOrignPoll1 performs a merge with any union data inside the StatusOrign_Poll, using the provided StatusOrignPoll1
func (t *StatusOrign_Poll) MergeStatusOrignPoll1(v StatusOrignPoll1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t StatusOrign_Poll) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *StatusOrign_Poll) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsPreviewCard returns the union data inside the StatusReblog_Card as a PreviewCard
func (t StatusReblog_Card) AsPreviewCard() (PreviewCard, error) {
	var body PreviewCard
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPreviewCard overwrites any union data inside the StatusReblog_Card as the provided PreviewCard
func (t *StatusReblog_Card) FromPreviewCard(v PreviewCard) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePreviewCard performs a merge with any union data inside the StatusReblog_Card, using the provided PreviewCard
func (t *StatusReblog_Card) MergePreviewCard(v PreviewCard) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsStatusReblogCard1 returns the union data inside the StatusReblog_Card as a StatusReblogCard1
func (t StatusReblog_Card) AsStatusReblogCard1() (StatusReblogCard1, error) {
	var body StatusReblogCard1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStatusReblogCard1 overwrites any union data inside the StatusReblog_Card as the provided StatusReblogCard1
func (t *StatusReblog_Card) FromStatusReblogCard1(v StatusReblogCard1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStatusReblogCard1 performs a merge with any union data inside the StatusReblog_Card, using the provided StatusReblogCard1
func (t *StatusReblog_Card) MergeStatusReblogCard1(v StatusReblogCard1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t StatusReblog_Card) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *StatusReblog_Card) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsPoll returns the union data inside the StatusReblog_Poll as a Poll
func (t StatusReblog_Poll) AsPoll() (Poll, error) {
	var body Poll
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPoll overwrites any union data inside the StatusReblog_Poll as the provided Poll
func (t *StatusReblog_Poll) FromPoll(v Poll) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePoll performs a merge with any union data inside the StatusReblog_Poll, using the provided Poll
func (t *StatusReblog_Poll) MergePoll(v Poll) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsStatusReblogPoll1 returns the union data inside the StatusReblog_Poll as a StatusReblogPoll1
func (t StatusReblog_Poll) AsStatusReblogPoll1() (StatusReblogPoll1, error) {
	var body StatusReblogPoll1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStatusReblogPoll1 overwrites any union data inside the StatusReblog_Poll as the provided StatusReblogPoll1
func (t *StatusReblog_Poll) FromStatusReblogPoll1(v StatusReblogPoll1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStatusReblogPoll1 performs a merge with any union data inside the StatusReblog_Poll, using the provided StatusReblogPoll1
func (t *StatusReblog_Poll) MergeStatusReblogPoll1(v StatusReblogPoll1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t StatusReblog_Poll) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *StatusReblog_Poll) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Verify account credentials
	// (GET /api/v1/accounts/verify_credentials)
	GetApiV1AccountsVerifyCredentials(ctx echo.Context) error
	// Get account
	// (GET /api/v1/accounts/{uid})
	GetApiV1AccountsUid(ctx echo.Context, uid string) error
	// Get account’s statuses
	// (GET /api/v1/accounts/{uid}/statuses)
	GetApiV1AccountsUidStatuses(ctx echo.Context, uid string, params GetApiV1AccountsUidStatusesParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// GetApiV1AccountsVerifyCredentials converts echo context to params.
func (w *ServerInterfaceWrapper) GetApiV1AccountsVerifyCredentials(ctx echo.Context) error {
	var err error

	ctx.Set(NPubOrNSecScopes, []string{})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApiV1AccountsVerifyCredentials(ctx)
	return err
}

// GetApiV1AccountsUid converts echo context to params.
func (w *ServerInterfaceWrapper) GetApiV1AccountsUid(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "uid" -------------
	var uid string

	err = runtime.BindStyledParameterWithLocation("simple", false, "uid", runtime.ParamLocationPath, ctx.Param("uid"), &uid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter uid: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApiV1AccountsUid(ctx, uid)
	return err
}

// GetApiV1AccountsUidStatuses converts echo context to params.
func (w *ServerInterfaceWrapper) GetApiV1AccountsUidStatuses(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "uid" -------------
	var uid string

	err = runtime.BindStyledParameterWithLocation("simple", false, "uid", runtime.ParamLocationPath, ctx.Param("uid"), &uid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter uid: %s", err))
	}

	ctx.Set(NPubOrNSecScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApiV1AccountsUidStatusesParams
	// ------------- Optional query parameter "max_id" -------------

	err = runtime.BindQueryParameter("form", true, false, "max_id", ctx.QueryParams(), &params.MaxId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max_id: %s", err))
	}

	// ------------- Optional query parameter "since_id" -------------

	err = runtime.BindQueryParameter("form", true, false, "since_id", ctx.QueryParams(), &params.SinceId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter since_id: %s", err))
	}

	// ------------- Optional query parameter "min_id" -------------

	err = runtime.BindQueryParameter("form", true, false, "min_id", ctx.QueryParams(), &params.MinId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min_id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "only_media" -------------

	err = runtime.BindQueryParameter("form", true, false, "only_media", ctx.QueryParams(), &params.OnlyMedia)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter only_media: %s", err))
	}

	// ------------- Optional query parameter "exclude_replies" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude_replies", ctx.QueryParams(), &params.ExcludeReplies)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude_replies: %s", err))
	}

	// ------------- Optional query parameter "exclude_reblogs" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude_reblogs", ctx.QueryParams(), &params.ExcludeReblogs)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude_reblogs: %s", err))
	}

	// ------------- Optional query parameter "pinned" -------------

	err = runtime.BindQueryParameter("form", true, false, "pinned", ctx.QueryParams(), &params.Pinned)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter pinned: %s", err))
	}

	// ------------- Optional query parameter "tagged" -------------

	err = runtime.BindQueryParameter("form", true, false, "tagged", ctx.QueryParams(), &params.Tagged)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tagged: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApiV1AccountsUidStatuses(ctx, uid, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/api/v1/accounts/verify_credentials", wrapper.GetApiV1AccountsVerifyCredentials)
	router.GET(baseURL+"/api/v1/accounts/:uid", wrapper.GetApiV1AccountsUid)
	router.GET(baseURL+"/api/v1/accounts/:uid/statuses", wrapper.GetApiV1AccountsUidStatuses)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"BiWeB5EAAA==",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
