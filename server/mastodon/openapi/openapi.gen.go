// Package mopenapi provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.14.0 DO NOT EDIT.
package mopenapi

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"github.com/oapi-codegen/runtime"
)

const (
	NPubOrNSecScopes = "NPubOrNSec.Scopes"
)

// Defines values for FilterContext.
const (
	FilterContextAccount       FilterContext = "account"
	FilterContextHome          FilterContext = "home"
	FilterContextNotifications FilterContext = "notifications"
	FilterContextPublic        FilterContext = "public"
	FilterContextThread        FilterContext = "thread"
)

// Defines values for FilterFilterAction.
const (
	Hide FilterFilterAction = "hide"
	Warn FilterFilterAction = "warn"
)

// Defines values for MediaAttachmentType.
const (
	MediaAttachmentTypeAudio   MediaAttachmentType = "audio"
	MediaAttachmentTypeGif     MediaAttachmentType = "gif"
	MediaAttachmentTypeImage   MediaAttachmentType = "image"
	MediaAttachmentTypeUnknown MediaAttachmentType = "unknown"
	MediaAttachmentTypeVideo   MediaAttachmentType = "video"
)

// Defines values for PreviewCardType.
const (
	PreviewCardTypeLink  PreviewCardType = "link"
	PreviewCardTypePhoto PreviewCardType = "photo"
	PreviewCardTypeRich  PreviewCardType = "rich"
	PreviewCardTypeVideo PreviewCardType = "video"
)

// Defines values for SourcePrivacy.
const (
	SourcePrivacyDirect   SourcePrivacy = "direct"
	SourcePrivacyPrivate  SourcePrivacy = "private"
	SourcePrivacyPublic   SourcePrivacy = "public"
	SourcePrivacyUnlisted SourcePrivacy = "unlisted"
)

// Defines values for StatusVisibility.
const (
	StatusVisibilityDirect   StatusVisibility = "direct"
	StatusVisibilityPrivate  StatusVisibility = "private"
	StatusVisibilityPublic   StatusVisibility = "public"
	StatusVisibilityUnlisted StatusVisibility = "unlisted"
)

// Defines values for StatusOrignVisibility.
const (
	StatusOrignVisibilityDirect   StatusOrignVisibility = "direct"
	StatusOrignVisibilityPrivate  StatusOrignVisibility = "private"
	StatusOrignVisibilityPublic   StatusOrignVisibility = "public"
	StatusOrignVisibilityUnlisted StatusOrignVisibility = "unlisted"
)

// Defines values for StatusReblogVisibility.
const (
	Direct   StatusReblogVisibility = "direct"
	Private  StatusReblogVisibility = "private"
	Public   StatusReblogVisibility = "public"
	Unlisted StatusReblogVisibility = "unlisted"
)

// Account defines model for Account.
type Account struct {
	// Acct The Webfinger account URI. Equal to username for local users, or username@domain for remote users.
	Acct string `json:"acct"`

	// Avatar An image icon that is shown next to statuses and in the profile. (URL)
	Avatar string `json:"avatar"`

	// AvatarStatic A static version of the avatar. Equal to avatar if its value is a static image; different if avatar is an animated GIF.
	AvatarStatic string `json:"avatar_static"`

	// Bot Indicates that the account may perform automated actions, may not be monitored, or identifies
	Bot bool `json:"bot"`

	// CreatedAt When the account was created. (ISO 8601)
	CreatedAt string `json:"created_at"`

	// Discoverable Whether the account has opted into discovery features such as the profile directory.
	Discoverable *bool `json:"discoverable"`

	// DisplayName The profile’s display name.
	DisplayName string `json:"display_name"`

	// Emojis Custom emoji entities to be used when rendering the profile.
	Emojis []CustomEmoji `json:"emojis"`

	// Fields Custom emoji entities to be used when rendering the profile.
	Fields []Field `json:"fields"`

	// FollowersCount The reported followers of this profile.
	FollowersCount int `json:"followers_count"`

	// FollowingCount The reported follows of this profile.
	FollowingCount int `json:"following_count"`

	// Group Indicates that the account represents a Group actor.
	Group bool `json:"group"`

	// Header An image banner that is shown above the profile and in profile cards.
	Header string `json:"header"`

	// HeaderStatic A static version of the header. Equal to header if its value is a static image; different if header is an animated GIF.
	HeaderStatic string `json:"header_static"`

	// Id The account id.
	Id string `json:"id"`

	// LastStatusAt When the most recent status was posted. (ISO 8601)
	LastStatusAt *string `json:"last_status_at"`

	// Limited An extra attribute returned only when an account is silenced. If true, indicates that the account should be hidden behind a warning screen.
	Limited *bool `json:"limited,omitempty"`

	// Locked Whether the account manually approves follow requests.
	Locked bool `json:"locked"`

	// Moved Indicates that the profile is currently inactive and that its user has moved to a new account.
	Moved *bool `json:"moved"`

	// Noindex Whether the local user has opted out of being indexed by search engines.
	Noindex *bool `json:"noindex"`

	// Note The profile’s bio or description. (HTML)
	Note string `json:"note"`

	// StatusesCount How many statuses are attached to this account.
	StatusesCount int `json:"statuses_count"`

	// Suspended An extra attribute returned only when an account is suspended.
	Suspended *bool `json:"suspended,omitempty"`

	// Url The location of the user’s profile page.
	Url string `json:"url"`

	// Username The username of the account, not including domain.
	Username string `json:"username"`
}

// Application defines model for Application.
type Application struct {
	Name    *string `json:"name"`
	Website *string `json:"website"`
}

// CredentialAccount defines model for CredentialAccount.
type CredentialAccount struct {
	// Acct The Webfinger account URI. Equal to username for local users, or username@domain for remote users.
	Acct string `json:"acct"`

	// Avatar An image icon that is shown next to statuses and in the profile. (URL)
	Avatar string `json:"avatar"`

	// AvatarStatic A static version of the avatar. Equal to avatar if its value is a static image; different if avatar is an animated GIF.
	AvatarStatic string `json:"avatar_static"`

	// Bot Indicates that the account may perform automated actions, may not be monitored, or identifies
	Bot bool `json:"bot"`

	// CreatedAt When the account was created. (ISO 8601)
	CreatedAt string `json:"created_at"`

	// Discoverable Whether the account has opted into discovery features such as the profile directory.
	Discoverable *bool `json:"discoverable"`

	// DisplayName The profile’s display name.
	DisplayName string `json:"display_name"`

	// Emojis Custom emoji entities to be used when rendering the profile.
	Emojis []CustomEmoji `json:"emojis"`

	// Fields Custom emoji entities to be used when rendering the profile.
	Fields []Field `json:"fields"`

	// FollowersCount The reported followers of this profile.
	FollowersCount int `json:"followers_count"`

	// FollowingCount The reported follows of this profile.
	FollowingCount int `json:"following_count"`

	// Group Indicates that the account represents a Group actor.
	Group bool `json:"group"`

	// Header An image banner that is shown above the profile and in profile cards.
	Header string `json:"header"`

	// HeaderStatic A static version of the header. Equal to header if its value is a static image; different if header is an animated GIF.
	HeaderStatic string `json:"header_static"`

	// Id The account id.
	Id string `json:"id"`

	// LastStatusAt When the most recent status was posted. (ISO 8601)
	LastStatusAt *string `json:"last_status_at"`

	// Limited An extra attribute returned only when an account is silenced. If true, indicates that the account should be hidden behind a warning screen.
	Limited *bool `json:"limited,omitempty"`

	// Locked Whether the account manually approves follow requests.
	Locked bool `json:"locked"`

	// Moved Indicates that the profile is currently inactive and that its user has moved to a new account.
	Moved *bool `json:"moved"`

	// Noindex Whether the local user has opted out of being indexed by search engines.
	Noindex *bool `json:"noindex"`

	// Note The profile’s bio or description. (HTML)
	Note   string `json:"note"`
	Role   Role   `json:"role"`
	Source Source `json:"source"`

	// StatusesCount How many statuses are attached to this account.
	StatusesCount int `json:"statuses_count"`

	// Suspended An extra attribute returned only when an account is suspended.
	Suspended *bool `json:"suspended,omitempty"`

	// Url The location of the user’s profile page.
	Url string `json:"url"`

	// Username The username of the account, not including domain.
	Username string `json:"username"`
}

// CustomEmoji defines model for CustomEmoji.
type CustomEmoji struct {
	// Category Used for sorting custom emoji in the picker.
	Category string `json:"category"`

	// Shortcode The name of the custom emoji.
	Shortcode string `json:"shortcode"`

	// StaticUrl A link to a static copy of the custom emoji.
	StaticUrl string `json:"static_url"`

	// Url A link to the custom emoji.
	Url string `json:"url"`

	// VisibleInPicker Whether this Emoji should be visible in the picker or unlisted.
	VisibleInPicker bool `json:"visible_in_picker"`
}

// Field defines model for Field.
type Field struct {
	// Name The key of a given field’s key-value pair.
	Name string `json:"name"`

	// Value The value associated with the name key.
	Value string `json:"value"`

	// VerifiedAt Timestamp of when the server verified a URL value for a rel=“me” link.
	VerifiedAt *string `json:"verified_at"`
}

// Filter Represents a user-defined filter for determining which statuses should not be shown to the user.
type Filter struct {
	// Context The contexts in which the filter should be applied.
	Context []FilterContext `json:"context"`

	// ExpiresAt When the filter should no longer be applied.
	ExpiresAt *string `json:"expires_at"`

	// FilterAction The action to be taken when a status matches this filter.
	FilterAction FilterFilterAction `json:"filter_action"`

	// Id The ID of the Filter in the database.
	Id string `json:"id"`

	// Keywords The keywords grouped under this filter.
	Keywords []FilterKeyword `json:"keywords"`

	// Statuses The statuses grouped under this filter.
	Statuses []FilterStatus `json:"statuses"`

	// Title A title given by the user to name the filter.
	Title string `json:"title"`
}

// FilterContext defines model for Filter.Context.
type FilterContext string

// FilterFilterAction The action to be taken when a status matches this filter.
type FilterFilterAction string

// FilterKeyword Represents a keyword that, if matched, should cause the filter action to be taken.
type FilterKeyword struct {
	// Id The ID of the FilterKeyword in the database.
	Id string `json:"id"`

	// Keyword The phrase to be matched against.
	Keyword string `json:"keyword"`

	// WholeWord Should the filter consider word boundaries? See implementation guidelines for filters.
	WholeWord bool `json:"whole_word"`
}

// FilterResult Represents a filter whose keywords matched a given status.
type FilterResult struct {
	// Filter Represents a user-defined filter for determining which statuses should not be shown to the user.
	Filter Filter `json:"filter"`

	// KeywordMatches The keyword within the filter that was matched.
	KeywordMatches *[]string `json:"keyword_matches"`

	// StatusMatches The status ID within the filter that was matched.
	StatusMatches *[]string `json:"status_matches"`
}

// FilterStatus Represents a status ID that, if matched, should cause the filter action to be taken.
type FilterStatus struct {
	// Id The ID of the FilterStatus in the database.
	Id string `json:"id"`

	// StatusId The ID of the Status that will be filtered.
	StatusId string `json:"status_id"`
}

// MediaAttachment defines model for MediaAttachment.
type MediaAttachment struct {
	// Blurhash A hash computed by the BlurHash algorithm, for generating colorful preview thumbnails when media has not been downloaded yet.
	Blurhash string `json:"blurhash"`

	// Description Alternate text that describes what is in the media attachment, to be used for the visually impaired or when media attachments do not load.
	Description string `json:"description"`

	// Id The ID of the attachment in the database.
	Id   string         `json:"id"`
	Meta MediaImegeMeta `json:"meta"`

	// PreviewUrl The location of a scaled-down preview of the attachment.
	PreviewUrl string `json:"preview_url"`

	// RemoteUrl The location of the full-size original attachment on the remote website.
	RemoteUrl *string `json:"remote_url"`

	// Type The type of the attachment.
	Type MediaAttachmentType `json:"type"`

	// Url The location of the original full-size attachment.
	Url string `json:"url"`
}

// MediaAttachmentType The type of the attachment.
type MediaAttachmentType string

// MediaImageForcus defines model for MediaImageForcus.
type MediaImageForcus struct {
	X *float32 `json:"x,omitempty"`
	Y *float32 `json:"y,omitempty"`
}

// MediaImageSize defines model for MediaImageSize.
type MediaImageSize struct {
	Aspect *float32 `json:"aspect,omitempty"`
	Height *int     `json:"height,omitempty"`
	Size   *string  `json:"size,omitempty"`
	Width  *int     `json:"width,omitempty"`
}

// MediaImegeMeta defines model for MediaImegeMeta.
type MediaImegeMeta struct {
	Focus    *MediaImageForcus `json:"focus,omitempty"`
	Original *MediaImageSize   `json:"original,omitempty"`
	Small    *MediaImageSize   `json:"small,omitempty"`
}

// Poll Represents a poll attached to a status.
type Poll struct {
	// Emojis Custom emoji to be used for rendering poll options.
	Emojis []CustomEmoji `json:"emojis"`

	// Expired Is the poll currently expired?
	Expired bool `json:"expired"`

	// ExpiresAt When the poll ends.
	ExpiresAt *string `json:"expires_at"`

	// Id The ID of the poll in the database.
	Id string `json:"id"`

	// Multiple Does the poll allow multiple-choice answers?
	Multiple bool `json:"multiple"`

	// Options Possible answers for the poll.
	Options []PollOption `json:"options"`

	// OwnVotes When called with a user token, which options has the authorized user chosen? Contains an array of index values for options.
	OwnVotes *[]int `json:"own_votes,omitempty"`

	// Voted When called with a user token, has the authorized user voted?
	Voted *bool `json:"voted,omitempty"`

	// VotersCount How many unique accounts have voted on a multiple-choice poll.
	VotersCount *int `json:"voters_count"`

	// VotesCount How many votes have been received.
	VotesCount int `json:"votes_count"`
}

// PollOption defines model for PollOption.
type PollOption struct {
	// Title The text value of the poll option.
	Title string `json:"title"`

	// VotesCount The total number of received votes for this option.
	VotesCount *int `json:"votes_count"`
}

// PreviewCard Represents a rich preview card that is generated using OpenGraph tags from a URL.
type PreviewCard struct {
	// AuthorName The author of the original resource.
	AuthorName string `json:"author_name"`

	// AuthorUrl A link to the author of the original resource.
	AuthorUrl string `json:"author_url"`

	// Blurhash A hash computed by the BlurHash algorithm, for generating colorful preview thumbnails when media has not been downloaded yet.
	Blurhash *string `json:"blurhash"`

	// Description Description of preview.
	Description string `json:"description"`

	// EmbedUrl Used for photo embeds, instead of custom html.
	EmbedUrl string `json:"embed_url"`

	// Height Height of preview, in pixels.
	Height int `json:"height"`

	// Html HTML to be used for generating the preview card.
	Html string `json:"html"`

	// Image Preview thumbnail.
	Image *string `json:"image"`

	// ProviderName The provider of the original resource.
	ProviderName string `json:"provider_name"`

	// ProviderUrl A link to the provider of the original resource.
	ProviderUrl string `json:"provider_url"`

	// Title Title of linked resource.
	Title string `json:"title"`

	// Type The type of the preview card.
	Type PreviewCardType `json:"type"`

	// Url Location of linked resource.
	Url string `json:"url"`

	// Width Width of preview, in pixels.
	Width int `json:"width"`
}

// PreviewCardType The type of the preview card.
type PreviewCardType string

// Role defines model for Role.
type Role struct {
	// Color The hex code assigned to this role. If no hex code is assigned, the string will be empty.
	Color string `json:"color"`

	// Highlighted  Whether the role is publicly visible as a badge on user profiles.
	Highlighted bool `json:"highlighted"`

	// Id The ID of the Role in the database.
	Id int `json:"id"`

	// Name The name of the role.
	Name string `json:"name"`

	// Permissions A bitmask that represents the sum of all permissions granted to the role.
	Permissions int `json:"permissions"`
}

// Source defines model for Source.
type Source struct {
	// Fields Metadata about the account.
	Fields []Field `json:"fields"`

	// FollowRequestsCount The number of pending follow requests.
	FollowRequestsCount int `json:"follow_requests_count"`

	// Language The default posting language for new statuses. (ISO 639-1 language two-letter code) or empty string.
	Language string `json:"language"`

	// Note Profile bio, in plain-text instead of in HTML.
	Note string `json:"note"`

	// Privacy The default post privacy to be used for new statuses.
	Privacy SourcePrivacy `json:"privacy"`

	// Sensitive Whether new statuses should be marked sensitive by default.
	Sensitive bool `json:"sensitive"`
}

// SourcePrivacy The default post privacy to be used for new statuses.
type SourcePrivacy string

// Status defines model for Status.
type Status struct {
	Account     Account      `json:"account"`
	Application *Application `json:"application,omitempty"`

	// Bookmarked If the current token has an authorized user: Have you bookmarked this status?
	Bookmarked *bool       `json:"bookmarked,omitempty"`
	Card       Status_Card `json:"card"`

	// Content HTML-encoded status content.
	Content string `json:"content"`

	// CreatedAt The date when this status was created.
	CreatedAt string `json:"created_at"`

	// EditedAt Timestamp of when the status was last edited.
	EditedAt *string `json:"edited_at"`

	// Emojis Custom emoji to be used when rendering status content.
	Emojis []CustomEmoji `json:"emojis"`

	// Favourited If the current token has an authorized user: Have you favourited this status?
	Favourited *bool `json:"favourited,omitempty"`

	// FavouritesCount How many favourites this status has received.
	FavouritesCount int `json:"favourites_count"`

	// Filtered If the current token has an authorized user: The filter and keywords that matched this status.
	Filtered *[]FilterResult `json:"filtered,omitempty"`

	// Id ID of the status in the database.
	Id string `json:"id"`

	// InReplyToAccountId ID of the account that authored the status being replied to.
	InReplyToAccountId *string `json:"in_reply_to_account_id"`

	// InReplyToId ID of the status being replied to.
	InReplyToId *string `json:"in_reply_to_id"`

	// Language Primary language of this status.
	Language *string `json:"language"`

	// MediaAttachments Media that is attached to this status.
	MediaAttachments []MediaAttachment `json:"media_attachments"`

	// Mentions Mentions of users within the status content.
	Mentions []StatusMention `json:"mentions"`

	// Muted If the current token has an authorized user: Have you muted notifications for this status’s conversation?
	Muted *bool `json:"muted,omitempty"`

	// Pinned If the current token has an authorized user: Have you pinned this status? Only appears if the status is pinnable.
	Pinned *bool       `json:"pinned,omitempty"`
	Poll   Status_Poll `json:"poll"`

	// Reblog The status being reblogged.
	Reblog Status_Reblog `json:"reblog"`

	// Reblogged If the current token has an authorized user: Have you boosted this status?
	Reblogged *bool `json:"reblogged,omitempty"`

	// ReblogsCount How many boosts this status has received.
	ReblogsCount int `json:"reblogs_count"`

	// RepliesCount How many replies this status has received.
	RepliesCount int `json:"replies_count"`

	// Sensitive Is this status marked as sensitive content?
	Sensitive bool `json:"sensitive"`

	// SpoilerText Subject or summary line, below which status content is collapsed until expanded.
	SpoilerText string `json:"spoiler_text"`

	// Tags Hashtags used within the status content.
	Tags []StatusTag `json:"tags"`

	// Text Plain-text source of a status. Returned instead of content when status is deleted, so the user may redraft from the source text without the client having to reverse-engineer the original text from the HTML content.
	Text *string `json:"text"`

	// Uri URI of the status used for federation.
	Uri string `json:"uri"`

	// Url A link to the status’s HTML representation.
	Url *string `json:"url"`

	// Visibility Visibility of this status.
	Visibility StatusVisibility `json:"visibility"`
}

// StatusCard1 defines model for .
type StatusCard1 = map[string]interface{}

// Status_Card defines model for Status.Card.
type Status_Card struct {
	union json.RawMessage
}

// StatusPoll1 defines model for .
type StatusPoll1 = map[string]interface{}

// Status_Poll defines model for Status.Poll.
type Status_Poll struct {
	union json.RawMessage
}

// StatusReblog1 defines model for .
type StatusReblog1 = map[string]interface{}

// Status_Reblog The status being reblogged.
type Status_Reblog struct {
	union json.RawMessage
}

// StatusVisibility Visibility of this status.
type StatusVisibility string

// StatusMention defines model for StatusMention.
type StatusMention struct {
	// Acct The webfinger acct: URI of the mentioned user. Equivalent to username for local users, or username@domain for remote users.
	Acct string `json:"acct"`

	// Id The account ID of the mentioned user.
	Id string `json:"id"`

	// Url The location of the mentioned user’s profile.
	Url string `json:"url"`

	// Username The username of the mentioned user.
	Username string `json:"username"`
}

// StatusOrign Represents a status posted by an account.
type StatusOrign struct {
	Account     Account      `json:"account"`
	Application *Application `json:"application,omitempty"`

	// Bookmarked If the current token has an authorized user: Have you bookmarked this status?
	Bookmarked *bool            `json:"bookmarked,omitempty"`
	Card       StatusOrign_Card `json:"card"`

	// Content HTML-encoded status content.
	Content string `json:"content"`

	// CreatedAt The date when this status was created.
	CreatedAt string `json:"created_at"`

	// EditedAt Timestamp of when the status was last edited.
	EditedAt *string `json:"edited_at"`

	// Emojis Custom emoji to be used when rendering status content.
	Emojis []CustomEmoji `json:"emojis"`

	// Favourited If the current token has an authorized user: Have you favourited this status?
	Favourited *bool `json:"favourited,omitempty"`

	// FavouritesCount How many favourites this status has received.
	FavouritesCount int `json:"favourites_count"`

	// Filtered If the current token has an authorized user: The filter and keywords that matched this status.
	Filtered *[]FilterResult `json:"filtered,omitempty"`

	// Id ID of the status in the database.
	Id string `json:"id"`

	// InReplyToAccountId ID of the account that authored the status being replied to.
	InReplyToAccountId *string `json:"in_reply_to_account_id"`

	// InReplyToId ID of the status being replied to.
	InReplyToId *string `json:"in_reply_to_id"`

	// Language Primary language of this status.
	Language *string `json:"language"`

	// MediaAttachments Media that is attached to this status.
	MediaAttachments []MediaAttachment `json:"media_attachments"`

	// Mentions Mentions of users within the status content.
	Mentions []StatusMention `json:"mentions"`

	// Muted If the current token has an authorized user: Have you muted notifications for this status’s conversation?
	Muted *bool `json:"muted,omitempty"`

	// Pinned If the current token has an authorized user: Have you pinned this status? Only appears if the status is pinnable.
	Pinned *bool            `json:"pinned,omitempty"`
	Poll   StatusOrign_Poll `json:"poll"`

	// Reblogged If the current token has an authorized user: Have you boosted this status?
	Reblogged *bool `json:"reblogged,omitempty"`

	// ReblogsCount How many boosts this status has received.
	ReblogsCount int `json:"reblogs_count"`

	// RepliesCount How many replies this status has received.
	RepliesCount int `json:"replies_count"`

	// Sensitive Is this status marked as sensitive content?
	Sensitive bool `json:"sensitive"`

	// SpoilerText Subject or summary line, below which status content is collapsed until expanded.
	SpoilerText string `json:"spoiler_text"`

	// Tags Hashtags used within the status content.
	Tags []StatusTag `json:"tags"`

	// Text Plain-text source of a status. Returned instead of content when status is deleted, so the user may redraft from the source text without the client having to reverse-engineer the original text from the HTML content.
	Text *string `json:"text"`

	// Uri URI of the status used for federation.
	Uri string `json:"uri"`

	// Url A link to the status’s HTML representation.
	Url *string `json:"url"`

	// Visibility Visibility of this status.
	Visibility StatusOrignVisibility `json:"visibility"`
}

// StatusOrignCard1 defines model for .
type StatusOrignCard1 = map[string]interface{}

// StatusOrign_Card defines model for StatusOrign.Card.
type StatusOrign_Card struct {
	union json.RawMessage
}

// StatusOrignPoll1 defines model for .
type StatusOrignPoll1 = map[string]interface{}

// StatusOrign_Poll defines model for StatusOrign.Poll.
type StatusOrign_Poll struct {
	union json.RawMessage
}

// StatusOrignVisibility Visibility of this status.
type StatusOrignVisibility string

// StatusReblog defines model for StatusReblog.
type StatusReblog struct {
	Account     Account      `json:"account"`
	Application *Application `json:"application,omitempty"`

	// Bookmarked If the current token has an authorized user: Have you bookmarked this status?
	Bookmarked *bool             `json:"bookmarked,omitempty"`
	Card       StatusReblog_Card `json:"card"`

	// Content HTML-encoded status content.
	Content string `json:"content"`

	// CreatedAt The date when this status was created.
	CreatedAt string `json:"created_at"`

	// EditedAt Timestamp of when the status was last edited.
	EditedAt *string `json:"edited_at"`

	// Emojis Custom emoji to be used when rendering status content.
	Emojis []CustomEmoji `json:"emojis"`

	// Favourited If the current token has an authorized user: Have you favourited this status?
	Favourited *bool `json:"favourited,omitempty"`

	// FavouritesCount How many favourites this status has received.
	FavouritesCount int `json:"favourites_count"`

	// Filtered If the current token has an authorized user: The filter and keywords that matched this status.
	Filtered *[]FilterResult `json:"filtered,omitempty"`

	// Id ID of the status in the database.
	Id string `json:"id"`

	// InReplyToAccountId ID of the account that authored the status being replied to.
	InReplyToAccountId *string `json:"in_reply_to_account_id"`

	// InReplyToId ID of the status being replied to.
	InReplyToId *string `json:"in_reply_to_id"`

	// Language Primary language of this status.
	Language *string `json:"language"`

	// MediaAttachments Media that is attached to this status.
	MediaAttachments []MediaAttachment `json:"media_attachments"`

	// Mentions Mentions of users within the status content.
	Mentions []StatusMention `json:"mentions"`

	// Muted If the current token has an authorized user: Have you muted notifications for this status’s conversation?
	Muted *bool `json:"muted,omitempty"`

	// Pinned If the current token has an authorized user: Have you pinned this status? Only appears if the status is pinnable.
	Pinned *bool                   `json:"pinned,omitempty"`
	Poll   StatusReblog_Poll       `json:"poll"`
	Reblog *map[string]interface{} `json:"reblog"`

	// Reblogged If the current token has an authorized user: Have you boosted this status?
	Reblogged *bool `json:"reblogged,omitempty"`

	// ReblogsCount How many boosts this status has received.
	ReblogsCount int `json:"reblogs_count"`

	// RepliesCount How many replies this status has received.
	RepliesCount int `json:"replies_count"`

	// Sensitive Is this status marked as sensitive content?
	Sensitive bool `json:"sensitive"`

	// SpoilerText Subject or summary line, below which status content is collapsed until expanded.
	SpoilerText string `json:"spoiler_text"`

	// Tags Hashtags used within the status content.
	Tags []StatusTag `json:"tags"`

	// Text Plain-text source of a status. Returned instead of content when status is deleted, so the user may redraft from the source text without the client having to reverse-engineer the original text from the HTML content.
	Text *string `json:"text"`

	// Uri URI of the status used for federation.
	Uri string `json:"uri"`

	// Url A link to the status’s HTML representation.
	Url *string `json:"url"`

	// Visibility Visibility of this status.
	Visibility StatusReblogVisibility `json:"visibility"`
}

// StatusReblogCard1 defines model for .
type StatusReblogCard1 = map[string]interface{}

// StatusReblog_Card defines model for StatusReblog.Card.
type StatusReblog_Card struct {
	union json.RawMessage
}

// StatusReblogPoll1 defines model for .
type StatusReblogPoll1 = map[string]interface{}

// StatusReblog_Poll defines model for StatusReblog.Poll.
type StatusReblog_Poll struct {
	union json.RawMessage
}

// StatusReblogVisibility Visibility of this status.
type StatusReblogVisibility string

// StatusTag defines model for StatusTag.
type StatusTag struct {
	// Name The value of the hashtag after the # sign.
	Name string `json:"name"`

	// Url A link to the hashtag on the instance.
	Url string `json:"url"`
}

// ExcludeReblogsQueryParam defines model for ExcludeReblogsQueryParam.
type ExcludeReblogsQueryParam = bool

// ExcludeRepliesQueryParam defines model for ExcludeRepliesQueryParam.
type ExcludeRepliesQueryParam = bool

// IsLocalParam defines model for IsLocalParam.
type IsLocalParam = bool

// IsRemoteparam defines model for IsRemoteparam.
type IsRemoteparam = bool

// LimitQueryParam defines model for LimitQueryParam.
type LimitQueryParam = int

// MaxIdQueryParam defines model for MaxIdQueryParam.
type MaxIdQueryParam = string

// MinIdQueryParam defines model for MinIdQueryParam.
type MinIdQueryParam = string

// OnlyMediaQueryParam defines model for OnlyMediaQueryParam.
type OnlyMediaQueryParam = bool

// PinnedQueryParam defines model for PinnedQueryParam.
type PinnedQueryParam = bool

// SinceIdQueryParam defines model for SinceIdQueryParam.
type SinceIdQueryParam = string

// TaggedQueryParam defines model for TaggedQueryParam.
type TaggedQueryParam = string

// GetApiV1AccountsUidStatusesParams defines parameters for GetApiV1AccountsUidStatuses.
type GetApiV1AccountsUidStatusesParams struct {
	// MaxId Return results older than this ID
	MaxId *MaxIdQueryParam `form:"max_id,omitempty" json:"max_id,omitempty"`

	// SinceId Return results newer than this ID
	SinceId *SinceIdQueryParam `form:"since_id,omitempty" json:"since_id,omitempty"`

	// MinId Return results immediately newer than this ID
	MinId *MinIdQueryParam `form:"min_id,omitempty" json:"min_id,omitempty"`

	// Limit Maximum number of results to return. Defaults to 20 statuses. Max 40 statuses.
	Limit *LimitQueryParam `form:"limit,omitempty" json:"limit,omitempty"`

	// OnlyMedia Filter out statuses without attachments.
	OnlyMedia *OnlyMediaQueryParam `form:"only_media,omitempty" json:"only_media,omitempty"`

	// ExcludeReplies Filter out statuses in reply to a different account.
	ExcludeReplies *ExcludeRepliesQueryParam `form:"exclude_replies,omitempty" json:"exclude_replies,omitempty"`

	// ExcludeReblogs Filter out boosts from the response.
	ExcludeReblogs *ExcludeReblogsQueryParam `form:"exclude_reblogs,omitempty" json:"exclude_reblogs,omitempty"`

	// Pinned Filter for pinned statuses only.
	Pinned *PinnedQueryParam `form:"pinned,omitempty" json:"pinned,omitempty"`

	// Tagged Filter for statuses using a specific hashtag.
	Tagged *TaggedQueryParam `form:"tagged,omitempty" json:"tagged,omitempty"`
}

// GetApiV1TimelinesPublicParams defines parameters for GetApiV1TimelinesPublic.
type GetApiV1TimelinesPublicParams struct {
	// Local Boolean. Show only local statuses? Defaults to false.
	Local *IsLocalParam `form:"local,omitempty" json:"local,omitempty"`

	// Remote Boolean. Show only remote statuses? Defaults to false.
	Remote *IsRemoteparam `form:"remote,omitempty" json:"remote,omitempty"`

	// OnlyMedia Filter out statuses without attachments.
	OnlyMedia *OnlyMediaQueryParam `form:"only_media,omitempty" json:"only_media,omitempty"`

	// MaxId Return results older than this ID
	MaxId *MaxIdQueryParam `form:"max_id,omitempty" json:"max_id,omitempty"`

	// SinceId Return results newer than this ID
	SinceId *SinceIdQueryParam `form:"since_id,omitempty" json:"since_id,omitempty"`

	// MinId Return results immediately newer than this ID
	MinId *MinIdQueryParam `form:"min_id,omitempty" json:"min_id,omitempty"`

	// Limit Maximum number of results to return. Defaults to 20 statuses. Max 40 statuses.
	Limit *LimitQueryParam `form:"limit,omitempty" json:"limit,omitempty"`
}

// AsPreviewCard returns the union data inside the Status_Card as a PreviewCard
func (t Status_Card) AsPreviewCard() (PreviewCard, error) {
	var body PreviewCard
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPreviewCard overwrites any union data inside the Status_Card as the provided PreviewCard
func (t *Status_Card) FromPreviewCard(v PreviewCard) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePreviewCard performs a merge with any union data inside the Status_Card, using the provided PreviewCard
func (t *Status_Card) MergePreviewCard(v PreviewCard) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsStatusCard1 returns the union data inside the Status_Card as a StatusCard1
func (t Status_Card) AsStatusCard1() (StatusCard1, error) {
	var body StatusCard1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStatusCard1 overwrites any union data inside the Status_Card as the provided StatusCard1
func (t *Status_Card) FromStatusCard1(v StatusCard1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStatusCard1 performs a merge with any union data inside the Status_Card, using the provided StatusCard1
func (t *Status_Card) MergeStatusCard1(v StatusCard1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t Status_Card) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Status_Card) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsPoll returns the union data inside the Status_Poll as a Poll
func (t Status_Poll) AsPoll() (Poll, error) {
	var body Poll
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPoll overwrites any union data inside the Status_Poll as the provided Poll
func (t *Status_Poll) FromPoll(v Poll) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePoll performs a merge with any union data inside the Status_Poll, using the provided Poll
func (t *Status_Poll) MergePoll(v Poll) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsStatusPoll1 returns the union data inside the Status_Poll as a StatusPoll1
func (t Status_Poll) AsStatusPoll1() (StatusPoll1, error) {
	var body StatusPoll1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStatusPoll1 overwrites any union data inside the Status_Poll as the provided StatusPoll1
func (t *Status_Poll) FromStatusPoll1(v StatusPoll1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStatusPoll1 performs a merge with any union data inside the Status_Poll, using the provided StatusPoll1
func (t *Status_Poll) MergeStatusPoll1(v StatusPoll1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t Status_Poll) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Status_Poll) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsStatusReblog returns the union data inside the Status_Reblog as a StatusReblog
func (t Status_Reblog) AsStatusReblog() (StatusReblog, error) {
	var body StatusReblog
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStatusReblog overwrites any union data inside the Status_Reblog as the provided StatusReblog
func (t *Status_Reblog) FromStatusReblog(v StatusReblog) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStatusReblog performs a merge with any union data inside the Status_Reblog, using the provided StatusReblog
func (t *Status_Reblog) MergeStatusReblog(v StatusReblog) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsStatusReblog1 returns the union data inside the Status_Reblog as a StatusReblog1
func (t Status_Reblog) AsStatusReblog1() (StatusReblog1, error) {
	var body StatusReblog1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStatusReblog1 overwrites any union data inside the Status_Reblog as the provided StatusReblog1
func (t *Status_Reblog) FromStatusReblog1(v StatusReblog1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStatusReblog1 performs a merge with any union data inside the Status_Reblog, using the provided StatusReblog1
func (t *Status_Reblog) MergeStatusReblog1(v StatusReblog1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t Status_Reblog) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Status_Reblog) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsPreviewCard returns the union data inside the StatusOrign_Card as a PreviewCard
func (t StatusOrign_Card) AsPreviewCard() (PreviewCard, error) {
	var body PreviewCard
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPreviewCard overwrites any union data inside the StatusOrign_Card as the provided PreviewCard
func (t *StatusOrign_Card) FromPreviewCard(v PreviewCard) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePreviewCard performs a merge with any union data inside the StatusOrign_Card, using the provided PreviewCard
func (t *StatusOrign_Card) MergePreviewCard(v PreviewCard) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsStatusOrignCard1 returns the union data inside the StatusOrign_Card as a StatusOrignCard1
func (t StatusOrign_Card) AsStatusOrignCard1() (StatusOrignCard1, error) {
	var body StatusOrignCard1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStatusOrignCard1 overwrites any union data inside the StatusOrign_Card as the provided StatusOrignCard1
func (t *StatusOrign_Card) FromStatusOrignCard1(v StatusOrignCard1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStatusOrignCard1 performs a merge with any union data inside the StatusOrign_Card, using the provided StatusOrignCard1
func (t *StatusOrign_Card) MergeStatusOrignCard1(v StatusOrignCard1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t StatusOrign_Card) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *StatusOrign_Card) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsPoll returns the union data inside the StatusOrign_Poll as a Poll
func (t StatusOrign_Poll) AsPoll() (Poll, error) {
	var body Poll
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPoll overwrites any union data inside the StatusOrign_Poll as the provided Poll
func (t *StatusOrign_Poll) FromPoll(v Poll) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePoll performs a merge with any union data inside the StatusOrign_Poll, using the provided Poll
func (t *StatusOrign_Poll) MergePoll(v Poll) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsStatusOrignPoll1 returns the union data inside the StatusOrign_Poll as a StatusOrignPoll1
func (t StatusOrign_Poll) AsStatusOrignPoll1() (StatusOrignPoll1, error) {
	var body StatusOrignPoll1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStatusOrignPoll1 overwrites any union data inside the StatusOrign_Poll as the provided StatusOrignPoll1
func (t *StatusOrign_Poll) FromStatusOrignPoll1(v StatusOrignPoll1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStatusOrignPoll1 performs a merge with any union data inside the StatusOrign_Poll, using the provided StatusOrignPoll1
func (t *StatusOrign_Poll) MergeStatusOrignPoll1(v StatusOrignPoll1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t StatusOrign_Poll) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *StatusOrign_Poll) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsPreviewCard returns the union data inside the StatusReblog_Card as a PreviewCard
func (t StatusReblog_Card) AsPreviewCard() (PreviewCard, error) {
	var body PreviewCard
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPreviewCard overwrites any union data inside the StatusReblog_Card as the provided PreviewCard
func (t *StatusReblog_Card) FromPreviewCard(v PreviewCard) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePreviewCard performs a merge with any union data inside the StatusReblog_Card, using the provided PreviewCard
func (t *StatusReblog_Card) MergePreviewCard(v PreviewCard) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsStatusReblogCard1 returns the union data inside the StatusReblog_Card as a StatusReblogCard1
func (t StatusReblog_Card) AsStatusReblogCard1() (StatusReblogCard1, error) {
	var body StatusReblogCard1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStatusReblogCard1 overwrites any union data inside the StatusReblog_Card as the provided StatusReblogCard1
func (t *StatusReblog_Card) FromStatusReblogCard1(v StatusReblogCard1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStatusReblogCard1 performs a merge with any union data inside the StatusReblog_Card, using the provided StatusReblogCard1
func (t *StatusReblog_Card) MergeStatusReblogCard1(v StatusReblogCard1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t StatusReblog_Card) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *StatusReblog_Card) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsPoll returns the union data inside the StatusReblog_Poll as a Poll
func (t StatusReblog_Poll) AsPoll() (Poll, error) {
	var body Poll
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPoll overwrites any union data inside the StatusReblog_Poll as the provided Poll
func (t *StatusReblog_Poll) FromPoll(v Poll) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePoll performs a merge with any union data inside the StatusReblog_Poll, using the provided Poll
func (t *StatusReblog_Poll) MergePoll(v Poll) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsStatusReblogPoll1 returns the union data inside the StatusReblog_Poll as a StatusReblogPoll1
func (t StatusReblog_Poll) AsStatusReblogPoll1() (StatusReblogPoll1, error) {
	var body StatusReblogPoll1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStatusReblogPoll1 overwrites any union data inside the StatusReblog_Poll as the provided StatusReblogPoll1
func (t *StatusReblog_Poll) FromStatusReblogPoll1(v StatusReblogPoll1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStatusReblogPoll1 performs a merge with any union data inside the StatusReblog_Poll, using the provided StatusReblogPoll1
func (t *StatusReblog_Poll) MergeStatusReblogPoll1(v StatusReblogPoll1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t StatusReblog_Poll) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *StatusReblog_Poll) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Verify account credentials
	// (GET /api/v1/accounts/verify_credentials)
	GetApiV1AccountsVerifyCredentials(ctx echo.Context) error
	// Get account
	// (GET /api/v1/accounts/{uid})
	GetApiV1AccountsUid(ctx echo.Context, uid string) error
	// Get account’s statuses
	// (GET /api/v1/accounts/{uid}/statuses)
	GetApiV1AccountsUidStatuses(ctx echo.Context, uid string, params GetApiV1AccountsUidStatusesParams) error
	// View public timeline
	// (GET /api/v1/timelines/public)
	GetApiV1TimelinesPublic(ctx echo.Context, params GetApiV1TimelinesPublicParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// GetApiV1AccountsVerifyCredentials converts echo context to params.
func (w *ServerInterfaceWrapper) GetApiV1AccountsVerifyCredentials(ctx echo.Context) error {
	var err error

	ctx.Set(NPubOrNSecScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetApiV1AccountsVerifyCredentials(ctx)
	return err
}

// GetApiV1AccountsUid converts echo context to params.
func (w *ServerInterfaceWrapper) GetApiV1AccountsUid(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "uid" -------------
	var uid string

	err = runtime.BindStyledParameterWithLocation("simple", false, "uid", runtime.ParamLocationPath, ctx.Param("uid"), &uid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter uid: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetApiV1AccountsUid(ctx, uid)
	return err
}

// GetApiV1AccountsUidStatuses converts echo context to params.
func (w *ServerInterfaceWrapper) GetApiV1AccountsUidStatuses(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "uid" -------------
	var uid string

	err = runtime.BindStyledParameterWithLocation("simple", false, "uid", runtime.ParamLocationPath, ctx.Param("uid"), &uid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter uid: %s", err))
	}

	ctx.Set(NPubOrNSecScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApiV1AccountsUidStatusesParams
	// ------------- Optional query parameter "max_id" -------------

	err = runtime.BindQueryParameter("form", true, false, "max_id", ctx.QueryParams(), &params.MaxId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max_id: %s", err))
	}

	// ------------- Optional query parameter "since_id" -------------

	err = runtime.BindQueryParameter("form", true, false, "since_id", ctx.QueryParams(), &params.SinceId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter since_id: %s", err))
	}

	// ------------- Optional query parameter "min_id" -------------

	err = runtime.BindQueryParameter("form", true, false, "min_id", ctx.QueryParams(), &params.MinId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min_id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "only_media" -------------

	err = runtime.BindQueryParameter("form", true, false, "only_media", ctx.QueryParams(), &params.OnlyMedia)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter only_media: %s", err))
	}

	// ------------- Optional query parameter "exclude_replies" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude_replies", ctx.QueryParams(), &params.ExcludeReplies)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude_replies: %s", err))
	}

	// ------------- Optional query parameter "exclude_reblogs" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude_reblogs", ctx.QueryParams(), &params.ExcludeReblogs)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude_reblogs: %s", err))
	}

	// ------------- Optional query parameter "pinned" -------------

	err = runtime.BindQueryParameter("form", true, false, "pinned", ctx.QueryParams(), &params.Pinned)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter pinned: %s", err))
	}

	// ------------- Optional query parameter "tagged" -------------

	err = runtime.BindQueryParameter("form", true, false, "tagged", ctx.QueryParams(), &params.Tagged)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tagged: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetApiV1AccountsUidStatuses(ctx, uid, params)
	return err
}

// GetApiV1TimelinesPublic converts echo context to params.
func (w *ServerInterfaceWrapper) GetApiV1TimelinesPublic(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApiV1TimelinesPublicParams
	// ------------- Optional query parameter "local" -------------

	err = runtime.BindQueryParameter("form", true, false, "local", ctx.QueryParams(), &params.Local)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter local: %s", err))
	}

	// ------------- Optional query parameter "remote" -------------

	err = runtime.BindQueryParameter("form", true, false, "remote", ctx.QueryParams(), &params.Remote)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter remote: %s", err))
	}

	// ------------- Optional query parameter "only_media" -------------

	err = runtime.BindQueryParameter("form", true, false, "only_media", ctx.QueryParams(), &params.OnlyMedia)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter only_media: %s", err))
	}

	// ------------- Optional query parameter "max_id" -------------

	err = runtime.BindQueryParameter("form", true, false, "max_id", ctx.QueryParams(), &params.MaxId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max_id: %s", err))
	}

	// ------------- Optional query parameter "since_id" -------------

	err = runtime.BindQueryParameter("form", true, false, "since_id", ctx.QueryParams(), &params.SinceId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter since_id: %s", err))
	}

	// ------------- Optional query parameter "min_id" -------------

	err = runtime.BindQueryParameter("form", true, false, "min_id", ctx.QueryParams(), &params.MinId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min_id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetApiV1TimelinesPublic(ctx, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/api/v1/accounts/verify_credentials", wrapper.GetApiV1AccountsVerifyCredentials)
	router.GET(baseURL+"/api/v1/accounts/:uid", wrapper.GetApiV1AccountsUid)
	router.GET(baseURL+"/api/v1/accounts/:uid/statuses", wrapper.GetApiV1AccountsUidStatuses)
	router.GET(baseURL+"/api/v1/timelines/public", wrapper.GetApiV1TimelinesPublic)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
