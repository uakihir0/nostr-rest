// Package mopenapi provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.14.0 DO NOT EDIT.
package mopenapi

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"github.com/oapi-codegen/runtime"
)

const (
	NPubOrNSecScopes = "NPubOrNSec.Scopes"
)

// Defines values for FilterContext.
const (
	FilterContextAccount       FilterContext = "account"
	FilterContextHome          FilterContext = "home"
	FilterContextNotifications FilterContext = "notifications"
	FilterContextPublic        FilterContext = "public"
	FilterContextThread        FilterContext = "thread"
)

// Defines values for FilterFilterAction.
const (
	Hide FilterFilterAction = "hide"
	Warn FilterFilterAction = "warn"
)

// Defines values for MediaAttachmentType.
const (
	MediaAttachmentTypeAudio   MediaAttachmentType = "audio"
	MediaAttachmentTypeGif     MediaAttachmentType = "gif"
	MediaAttachmentTypeImage   MediaAttachmentType = "image"
	MediaAttachmentTypeUnknown MediaAttachmentType = "unknown"
	MediaAttachmentTypeVideo   MediaAttachmentType = "video"
)

// Defines values for PreviewCardType.
const (
	PreviewCardTypeLink  PreviewCardType = "link"
	PreviewCardTypePhoto PreviewCardType = "photo"
	PreviewCardTypeRich  PreviewCardType = "rich"
	PreviewCardTypeVideo PreviewCardType = "video"
)

// Defines values for SourcePrivacy.
const (
	SourcePrivacyDirect   SourcePrivacy = "direct"
	SourcePrivacyPrivate  SourcePrivacy = "private"
	SourcePrivacyPublic   SourcePrivacy = "public"
	SourcePrivacyUnlisted SourcePrivacy = "unlisted"
)

// Defines values for StatusVisibility.
const (
	StatusVisibilityDirect   StatusVisibility = "direct"
	StatusVisibilityPrivate  StatusVisibility = "private"
	StatusVisibilityPublic   StatusVisibility = "public"
	StatusVisibilityUnlisted StatusVisibility = "unlisted"
)

// Defines values for StatusOrignVisibility.
const (
	StatusOrignVisibilityDirect   StatusOrignVisibility = "direct"
	StatusOrignVisibilityPrivate  StatusOrignVisibility = "private"
	StatusOrignVisibilityPublic   StatusOrignVisibility = "public"
	StatusOrignVisibilityUnlisted StatusOrignVisibility = "unlisted"
)

// Defines values for StatusReblogVisibility.
const (
	Direct   StatusReblogVisibility = "direct"
	Private  StatusReblogVisibility = "private"
	Public   StatusReblogVisibility = "public"
	Unlisted StatusReblogVisibility = "unlisted"
)

// Account defines model for Account.
type Account struct {
	// Acct The Webfinger account URI. Equal to username for local users, or username@domain for remote users.
	Acct string `json:"acct"`

	// Avatar An image icon that is shown next to statuses and in the profile. (URL)
	Avatar string `json:"avatar"`

	// AvatarStatic A static version of the avatar. Equal to avatar if its value is a static image; different if avatar is an animated GIF.
	AvatarStatic string `json:"avatar_static"`

	// Bot Indicates that the account may perform automated actions, may not be monitored, or identifies
	Bot bool `json:"bot"`

	// CreatedAt When the account was created. (ISO 8601)
	CreatedAt string `json:"created_at"`

	// Discoverable Whether the account has opted into discovery features such as the profile directory.
	Discoverable *bool `json:"discoverable"`

	// DisplayName The profile’s display name.
	DisplayName string `json:"display_name"`

	// Emojis Custom emoji entities to be used when rendering the profile.
	Emojis []CustomEmoji `json:"emojis"`

	// Fields Custom emoji entities to be used when rendering the profile.
	Fields []Field `json:"fields"`

	// FollowersCount The reported followers of this profile.
	FollowersCount int `json:"followers_count"`

	// FollowingCount The reported follows of this profile.
	FollowingCount int `json:"following_count"`

	// Group Indicates that the account represents a Group actor.
	Group bool `json:"group"`

	// Header An image banner that is shown above the profile and in profile cards.
	Header string `json:"header"`

	// HeaderStatic A static version of the header. Equal to header if its value is a static image; different if header is an animated GIF.
	HeaderStatic string `json:"header_static"`

	// Id The account id.
	Id string `json:"id"`

	// LastStatusAt When the most recent status was posted. (ISO 8601)
	LastStatusAt *string `json:"last_status_at"`

	// Limited An extra attribute returned only when an account is silenced. If true, indicates that the account should be hidden behind a warning screen.
	Limited *bool `json:"limited,omitempty"`

	// Locked Whether the account manually approves follow requests.
	Locked bool `json:"locked"`

	// Moved Indicates that the profile is currently inactive and that its user has moved to a new account.
	Moved *bool `json:"moved"`

	// Noindex Whether the local user has opted out of being indexed by search engines.
	Noindex *bool `json:"noindex"`

	// Note The profile’s bio or description. (HTML)
	Note string `json:"note"`

	// StatusesCount How many statuses are attached to this account.
	StatusesCount int `json:"statuses_count"`

	// Suspended An extra attribute returned only when an account is suspended.
	Suspended *bool `json:"suspended,omitempty"`

	// Url The location of the user’s profile page.
	Url string `json:"url"`

	// Username The username of the account, not including domain.
	Username string `json:"username"`
}

// Application defines model for Application.
type Application struct {
	Name    *string `json:"name"`
	Website *string `json:"website"`
}

// CredentialAccount defines model for CredentialAccount.
type CredentialAccount struct {
	// Acct The Webfinger account URI. Equal to username for local users, or username@domain for remote users.
	Acct string `json:"acct"`

	// Avatar An image icon that is shown next to statuses and in the profile. (URL)
	Avatar string `json:"avatar"`

	// AvatarStatic A static version of the avatar. Equal to avatar if its value is a static image; different if avatar is an animated GIF.
	AvatarStatic string `json:"avatar_static"`

	// Bot Indicates that the account may perform automated actions, may not be monitored, or identifies
	Bot bool `json:"bot"`

	// CreatedAt When the account was created. (ISO 8601)
	CreatedAt string `json:"created_at"`

	// Discoverable Whether the account has opted into discovery features such as the profile directory.
	Discoverable *bool `json:"discoverable"`

	// DisplayName The profile’s display name.
	DisplayName string `json:"display_name"`

	// Emojis Custom emoji entities to be used when rendering the profile.
	Emojis []CustomEmoji `json:"emojis"`

	// Fields Custom emoji entities to be used when rendering the profile.
	Fields []Field `json:"fields"`

	// FollowersCount The reported followers of this profile.
	FollowersCount int `json:"followers_count"`

	// FollowingCount The reported follows of this profile.
	FollowingCount int `json:"following_count"`

	// Group Indicates that the account represents a Group actor.
	Group bool `json:"group"`

	// Header An image banner that is shown above the profile and in profile cards.
	Header string `json:"header"`

	// HeaderStatic A static version of the header. Equal to header if its value is a static image; different if header is an animated GIF.
	HeaderStatic string `json:"header_static"`

	// Id The account id.
	Id string `json:"id"`

	// LastStatusAt When the most recent status was posted. (ISO 8601)
	LastStatusAt *string `json:"last_status_at"`

	// Limited An extra attribute returned only when an account is silenced. If true, indicates that the account should be hidden behind a warning screen.
	Limited *bool `json:"limited,omitempty"`

	// Locked Whether the account manually approves follow requests.
	Locked bool `json:"locked"`

	// Moved Indicates that the profile is currently inactive and that its user has moved to a new account.
	Moved *bool `json:"moved"`

	// Noindex Whether the local user has opted out of being indexed by search engines.
	Noindex *bool `json:"noindex"`

	// Note The profile’s bio or description. (HTML)
	Note   string `json:"note"`
	Role   Role   `json:"role"`
	Source Source `json:"source"`

	// StatusesCount How many statuses are attached to this account.
	StatusesCount int `json:"statuses_count"`

	// Suspended An extra attribute returned only when an account is suspended.
	Suspended *bool `json:"suspended,omitempty"`

	// Url The location of the user’s profile page.
	Url string `json:"url"`

	// Username The username of the account, not including domain.
	Username string `json:"username"`
}

// CustomEmoji defines model for CustomEmoji.
type CustomEmoji struct {
	// Category Used for sorting custom emoji in the picker.
	Category string `json:"category"`

	// Shortcode The name of the custom emoji.
	Shortcode string `json:"shortcode"`

	// StaticUrl A link to a static copy of the custom emoji.
	StaticUrl string `json:"static_url"`

	// Url A link to the custom emoji.
	Url string `json:"url"`

	// VisibleInPicker Whether this Emoji should be visible in the picker or unlisted.
	VisibleInPicker bool `json:"visible_in_picker"`
}

// Field defines model for Field.
type Field struct {
	// Name The key of a given field’s key-value pair.
	Name string `json:"name"`

	// Value The value associated with the name key.
	Value string `json:"value"`

	// VerifiedAt Timestamp of when the server verified a URL value for a rel=“me” link.
	VerifiedAt *string `json:"verified_at"`
}

// Filter Represents a user-defined filter for determining which statuses should not be shown to the user.
type Filter struct {
	// Context The contexts in which the filter should be applied.
	Context []FilterContext `json:"context"`

	// ExpiresAt When the filter should no longer be applied.
	ExpiresAt *string `json:"expires_at"`

	// FilterAction The action to be taken when a status matches this filter.
	FilterAction FilterFilterAction `json:"filter_action"`

	// Id The ID of the Filter in the database.
	Id string `json:"id"`

	// Keywords The keywords grouped under this filter.
	Keywords []FilterKeyword `json:"keywords"`

	// Statuses The statuses grouped under this filter.
	Statuses []FilterStatus `json:"statuses"`

	// Title A title given by the user to name the filter.
	Title string `json:"title"`
}

// FilterContext defines model for Filter.Context.
type FilterContext string

// FilterFilterAction The action to be taken when a status matches this filter.
type FilterFilterAction string

// FilterKeyword Represents a keyword that, if matched, should cause the filter action to be taken.
type FilterKeyword struct {
	// Id The ID of the FilterKeyword in the database.
	Id string `json:"id"`

	// Keyword The phrase to be matched against.
	Keyword string `json:"keyword"`

	// WholeWord Should the filter consider word boundaries? See implementation guidelines for filters.
	WholeWord bool `json:"whole_word"`
}

// FilterResult Represents a filter whose keywords matched a given status.
type FilterResult struct {
	// Filter Represents a user-defined filter for determining which statuses should not be shown to the user.
	Filter Filter `json:"filter"`

	// KeywordMatches The keyword within the filter that was matched.
	KeywordMatches *[]string `json:"keyword_matches"`

	// StatusMatches The status ID within the filter that was matched.
	StatusMatches *[]string `json:"status_matches"`
}

// FilterStatus Represents a status ID that, if matched, should cause the filter action to be taken.
type FilterStatus struct {
	// Id The ID of the FilterStatus in the database.
	Id string `json:"id"`

	// StatusId The ID of the Status that will be filtered.
	StatusId string `json:"status_id"`
}

// MediaAttachment defines model for MediaAttachment.
type MediaAttachment struct {
	// Blurhash A hash computed by the BlurHash algorithm, for generating colorful preview thumbnails when media has not been downloaded yet.
	Blurhash string `json:"blurhash"`

	// Description Alternate text that describes what is in the media attachment, to be used for the visually impaired or when media attachments do not load.
	Description string `json:"description"`

	// Id The ID of the attachment in the database.
	Id   string         `json:"id"`
	Meta MediaImegeMeta `json:"meta"`

	// PreviewUrl The location of a scaled-down preview of the attachment.
	PreviewUrl string `json:"preview_url"`

	// RemoteUrl The location of the full-size original attachment on the remote website.
	RemoteUrl *string `json:"remote_url"`

	// Type The type of the attachment.
	Type MediaAttachmentType `json:"type"`

	// Url The location of the original full-size attachment.
	Url string `json:"url"`
}

// MediaAttachmentType The type of the attachment.
type MediaAttachmentType string

// MediaImageForcus defines model for MediaImageForcus.
type MediaImageForcus struct {
	X *float32 `json:"x,omitempty"`
	Y *float32 `json:"y,omitempty"`
}

// MediaImageSize defines model for MediaImageSize.
type MediaImageSize struct {
	Aspect *float32 `json:"aspect,omitempty"`
	Height *int     `json:"height,omitempty"`
	Size   *string  `json:"size,omitempty"`
	Width  *int     `json:"width,omitempty"`
}

// MediaImegeMeta defines model for MediaImegeMeta.
type MediaImegeMeta struct {
	Focus    *MediaImageForcus `json:"focus,omitempty"`
	Original *MediaImageSize   `json:"original,omitempty"`
	Small    *MediaImageSize   `json:"small,omitempty"`
}

// Poll Represents a poll attached to a status.
type Poll struct {
	// Emojis Custom emoji to be used for rendering poll options.
	Emojis []CustomEmoji `json:"emojis"`

	// Expired Is the poll currently expired?
	Expired bool `json:"expired"`

	// ExpiresAt When the poll ends.
	ExpiresAt *string `json:"expires_at"`

	// Id The ID of the poll in the database.
	Id string `json:"id"`

	// Multiple Does the poll allow multiple-choice answers?
	Multiple bool `json:"multiple"`

	// Options Possible answers for the poll.
	Options []PollOption `json:"options"`

	// OwnVotes When called with a user token, which options has the authorized user chosen? Contains an array of index values for options.
	OwnVotes *[]int `json:"own_votes,omitempty"`

	// Voted When called with a user token, has the authorized user voted?
	Voted *bool `json:"voted,omitempty"`

	// VotersCount How many unique accounts have voted on a multiple-choice poll.
	VotersCount *int `json:"voters_count"`

	// VotesCount How many votes have been received.
	VotesCount int `json:"votes_count"`
}

// PollOption defines model for PollOption.
type PollOption struct {
	// Title The text value of the poll option.
	Title string `json:"title"`

	// VotesCount The total number of received votes for this option.
	VotesCount *int `json:"votes_count"`
}

// PreviewCard Represents a rich preview card that is generated using OpenGraph tags from a URL.
type PreviewCard struct {
	// AuthorName The author of the original resource.
	AuthorName string `json:"author_name"`

	// AuthorUrl A link to the author of the original resource.
	AuthorUrl string `json:"author_url"`

	// Blurhash A hash computed by the BlurHash algorithm, for generating colorful preview thumbnails when media has not been downloaded yet.
	Blurhash *string `json:"blurhash"`

	// Description Description of preview.
	Description string `json:"description"`

	// EmbedUrl Used for photo embeds, instead of custom html.
	EmbedUrl string `json:"embed_url"`

	// Height Height of preview, in pixels.
	Height int `json:"height"`

	// Html HTML to be used for generating the preview card.
	Html string `json:"html"`

	// Image Preview thumbnail.
	Image *string `json:"image"`

	// ProviderName The provider of the original resource.
	ProviderName string `json:"provider_name"`

	// ProviderUrl A link to the provider of the original resource.
	ProviderUrl string `json:"provider_url"`

	// Title Title of linked resource.
	Title string `json:"title"`

	// Type The type of the preview card.
	Type PreviewCardType `json:"type"`

	// Url Location of linked resource.
	Url string `json:"url"`

	// Width Width of preview, in pixels.
	Width int `json:"width"`
}

// PreviewCardType The type of the preview card.
type PreviewCardType string

// Role defines model for Role.
type Role struct {
	// Color The hex code assigned to this role. If no hex code is assigned, the string will be empty.
	Color string `json:"color"`

	// Highlighted  Whether the role is publicly visible as a badge on user profiles.
	Highlighted bool `json:"highlighted"`

	// Id The ID of the Role in the database.
	Id int `json:"id"`

	// Name The name of the role.
	Name string `json:"name"`

	// Permissions A bitmask that represents the sum of all permissions granted to the role.
	Permissions int `json:"permissions"`
}

// Source defines model for Source.
type Source struct {
	// Fields Metadata about the account.
	Fields []Field `json:"fields"`

	// FollowRequestsCount The number of pending follow requests.
	FollowRequestsCount int `json:"follow_requests_count"`

	// Language The default posting language for new statuses. (ISO 639-1 language two-letter code) or empty string.
	Language string `json:"language"`

	// Note Profile bio, in plain-text instead of in HTML.
	Note string `json:"note"`

	// Privacy The default post privacy to be used for new statuses.
	Privacy SourcePrivacy `json:"privacy"`

	// Sensitive Whether new statuses should be marked sensitive by default.
	Sensitive bool `json:"sensitive"`
}

// SourcePrivacy The default post privacy to be used for new statuses.
type SourcePrivacy string

// Status defines model for Status.
type Status struct {
	Account     Account      `json:"account"`
	Application *Application `json:"application,omitempty"`

	// Bookmarked If the current token has an authorized user: Have you bookmarked this status?
	Bookmarked *bool       `json:"bookmarked,omitempty"`
	Card       Status_Card `json:"card"`

	// Content HTML-encoded status content.
	Content string `json:"content"`

	// CreatedAt The date when this status was created.
	CreatedAt string `json:"created_at"`

	// EditedAt Timestamp of when the status was last edited.
	EditedAt *string `json:"edited_at"`

	// Emojis Custom emoji to be used when rendering status content.
	Emojis []CustomEmoji `json:"emojis"`

	// Favourited If the current token has an authorized user: Have you favourited this status?
	Favourited *bool `json:"favourited,omitempty"`

	// FavouritesCount How many favourites this status has received.
	FavouritesCount int `json:"favourites_count"`

	// Filtered If the current token has an authorized user: The filter and keywords that matched this status.
	Filtered *[]FilterResult `json:"filtered,omitempty"`

	// Id ID of the status in the database.
	Id string `json:"id"`

	// InReplyToAccountId ID of the account that authored the status being replied to.
	InReplyToAccountId *string `json:"in_reply_to_account_id"`

	// InReplyToId ID of the status being replied to.
	InReplyToId *string `json:"in_reply_to_id"`

	// Language Primary language of this status.
	Language *string `json:"language"`

	// MediaAttachments Media that is attached to this status.
	MediaAttachments []MediaAttachment `json:"media_attachments"`

	// Mentions Mentions of users within the status content.
	Mentions []StatusMention `json:"mentions"`

	// Muted If the current token has an authorized user: Have you muted notifications for this status’s conversation?
	Muted *bool `json:"muted,omitempty"`

	// Pinned If the current token has an authorized user: Have you pinned this status? Only appears if the status is pinnable.
	Pinned *bool       `json:"pinned,omitempty"`
	Poll   Status_Poll `json:"poll"`

	// Reblog The status being reblogged.
	Reblog Status_Reblog `json:"reblog"`

	// Reblogged If the current token has an authorized user: Have you boosted this status?
	Reblogged *bool `json:"reblogged,omitempty"`

	// ReblogsCount How many boosts this status has received.
	ReblogsCount int `json:"reblogs_count"`

	// RepliesCount How many replies this status has received.
	RepliesCount int `json:"replies_count"`

	// Sensitive Is this status marked as sensitive content?
	Sensitive bool `json:"sensitive"`

	// SpoilerText Subject or summary line, below which status content is collapsed until expanded.
	SpoilerText string `json:"spoiler_text"`

	// Tags Hashtags used within the status content.
	Tags []StatusTag `json:"tags"`

	// Text Plain-text source of a status. Returned instead of content when status is deleted, so the user may redraft from the source text without the client having to reverse-engineer the original text from the HTML content.
	Text *string `json:"text"`

	// Uri URI of the status used for federation.
	Uri string `json:"uri"`

	// Url A link to the status’s HTML representation.
	Url *string `json:"url"`

	// Visibility Visibility of this status.
	Visibility StatusVisibility `json:"visibility"`
}

// StatusCard1 defines model for .
type StatusCard1 = map[string]interface{}

// Status_Card defines model for Status.Card.
type Status_Card struct {
	union json.RawMessage
}

// StatusPoll1 defines model for .
type StatusPoll1 = map[string]interface{}

// Status_Poll defines model for Status.Poll.
type Status_Poll struct {
	union json.RawMessage
}

// StatusReblog1 defines model for .
type StatusReblog1 = map[string]interface{}

// Status_Reblog The status being reblogged.
type Status_Reblog struct {
	union json.RawMessage
}

// StatusVisibility Visibility of this status.
type StatusVisibility string

// StatusMention defines model for StatusMention.
type StatusMention struct {
	// Acct The webfinger acct: URI of the mentioned user. Equivalent to username for local users, or username@domain for remote users.
	Acct string `json:"acct"`

	// Id The account ID of the mentioned user.
	Id string `json:"id"`

	// Url The location of the mentioned user’s profile.
	Url string `json:"url"`

	// Username The username of the mentioned user.
	Username string `json:"username"`
}

// StatusOrign Represents a status posted by an account.
type StatusOrign struct {
	Account     Account      `json:"account"`
	Application *Application `json:"application,omitempty"`

	// Bookmarked If the current token has an authorized user: Have you bookmarked this status?
	Bookmarked *bool            `json:"bookmarked,omitempty"`
	Card       StatusOrign_Card `json:"card"`

	// Content HTML-encoded status content.
	Content string `json:"content"`

	// CreatedAt The date when this status was created.
	CreatedAt string `json:"created_at"`

	// EditedAt Timestamp of when the status was last edited.
	EditedAt *string `json:"edited_at"`

	// Emojis Custom emoji to be used when rendering status content.
	Emojis []CustomEmoji `json:"emojis"`

	// Favourited If the current token has an authorized user: Have you favourited this status?
	Favourited *bool `json:"favourited,omitempty"`

	// FavouritesCount How many favourites this status has received.
	FavouritesCount int `json:"favourites_count"`

	// Filtered If the current token has an authorized user: The filter and keywords that matched this status.
	Filtered *[]FilterResult `json:"filtered,omitempty"`

	// Id ID of the status in the database.
	Id string `json:"id"`

	// InReplyToAccountId ID of the account that authored the status being replied to.
	InReplyToAccountId *string `json:"in_reply_to_account_id"`

	// InReplyToId ID of the status being replied to.
	InReplyToId *string `json:"in_reply_to_id"`

	// Language Primary language of this status.
	Language *string `json:"language"`

	// MediaAttachments Media that is attached to this status.
	MediaAttachments []MediaAttachment `json:"media_attachments"`

	// Mentions Mentions of users within the status content.
	Mentions []StatusMention `json:"mentions"`

	// Muted If the current token has an authorized user: Have you muted notifications for this status’s conversation?
	Muted *bool `json:"muted,omitempty"`

	// Pinned If the current token has an authorized user: Have you pinned this status? Only appears if the status is pinnable.
	Pinned *bool            `json:"pinned,omitempty"`
	Poll   StatusOrign_Poll `json:"poll"`

	// Reblogged If the current token has an authorized user: Have you boosted this status?
	Reblogged *bool `json:"reblogged,omitempty"`

	// ReblogsCount How many boosts this status has received.
	ReblogsCount int `json:"reblogs_count"`

	// RepliesCount How many replies this status has received.
	RepliesCount int `json:"replies_count"`

	// Sensitive Is this status marked as sensitive content?
	Sensitive bool `json:"sensitive"`

	// SpoilerText Subject or summary line, below which status content is collapsed until expanded.
	SpoilerText string `json:"spoiler_text"`

	// Tags Hashtags used within the status content.
	Tags []StatusTag `json:"tags"`

	// Text Plain-text source of a status. Returned instead of content when status is deleted, so the user may redraft from the source text without the client having to reverse-engineer the original text from the HTML content.
	Text *string `json:"text"`

	// Uri URI of the status used for federation.
	Uri string `json:"uri"`

	// Url A link to the status’s HTML representation.
	Url *string `json:"url"`

	// Visibility Visibility of this status.
	Visibility StatusOrignVisibility `json:"visibility"`
}

// StatusOrignCard1 defines model for .
type StatusOrignCard1 = map[string]interface{}

// StatusOrign_Card defines model for StatusOrign.Card.
type StatusOrign_Card struct {
	union json.RawMessage
}

// StatusOrignPoll1 defines model for .
type StatusOrignPoll1 = map[string]interface{}

// StatusOrign_Poll defines model for StatusOrign.Poll.
type StatusOrign_Poll struct {
	union json.RawMessage
}

// StatusOrignVisibility Visibility of this status.
type StatusOrignVisibility string

// StatusReblog defines model for StatusReblog.
type StatusReblog struct {
	Account     Account      `json:"account"`
	Application *Application `json:"application,omitempty"`

	// Bookmarked If the current token has an authorized user: Have you bookmarked this status?
	Bookmarked *bool             `json:"bookmarked,omitempty"`
	Card       StatusReblog_Card `json:"card"`

	// Content HTML-encoded status content.
	Content string `json:"content"`

	// CreatedAt The date when this status was created.
	CreatedAt string `json:"created_at"`

	// EditedAt Timestamp of when the status was last edited.
	EditedAt *string `json:"edited_at"`

	// Emojis Custom emoji to be used when rendering status content.
	Emojis []CustomEmoji `json:"emojis"`

	// Favourited If the current token has an authorized user: Have you favourited this status?
	Favourited *bool `json:"favourited,omitempty"`

	// FavouritesCount How many favourites this status has received.
	FavouritesCount int `json:"favourites_count"`

	// Filtered If the current token has an authorized user: The filter and keywords that matched this status.
	Filtered *[]FilterResult `json:"filtered,omitempty"`

	// Id ID of the status in the database.
	Id string `json:"id"`

	// InReplyToAccountId ID of the account that authored the status being replied to.
	InReplyToAccountId *string `json:"in_reply_to_account_id"`

	// InReplyToId ID of the status being replied to.
	InReplyToId *string `json:"in_reply_to_id"`

	// Language Primary language of this status.
	Language *string `json:"language"`

	// MediaAttachments Media that is attached to this status.
	MediaAttachments []MediaAttachment `json:"media_attachments"`

	// Mentions Mentions of users within the status content.
	Mentions []StatusMention `json:"mentions"`

	// Muted If the current token has an authorized user: Have you muted notifications for this status’s conversation?
	Muted *bool `json:"muted,omitempty"`

	// Pinned If the current token has an authorized user: Have you pinned this status? Only appears if the status is pinnable.
	Pinned *bool                   `json:"pinned,omitempty"`
	Poll   StatusReblog_Poll       `json:"poll"`
	Reblog *map[string]interface{} `json:"reblog"`

	// Reblogged If the current token has an authorized user: Have you boosted this status?
	Reblogged *bool `json:"reblogged,omitempty"`

	// ReblogsCount How many boosts this status has received.
	ReblogsCount int `json:"reblogs_count"`

	// RepliesCount How many replies this status has received.
	RepliesCount int `json:"replies_count"`

	// Sensitive Is this status marked as sensitive content?
	Sensitive bool `json:"sensitive"`

	// SpoilerText Subject or summary line, below which status content is collapsed until expanded.
	SpoilerText string `json:"spoiler_text"`

	// Tags Hashtags used within the status content.
	Tags []StatusTag `json:"tags"`

	// Text Plain-text source of a status. Returned instead of content when status is deleted, so the user may redraft from the source text without the client having to reverse-engineer the original text from the HTML content.
	Text *string `json:"text"`

	// Uri URI of the status used for federation.
	Uri string `json:"uri"`

	// Url A link to the status’s HTML representation.
	Url *string `json:"url"`

	// Visibility Visibility of this status.
	Visibility StatusReblogVisibility `json:"visibility"`
}

// StatusReblogCard1 defines model for .
type StatusReblogCard1 = map[string]interface{}

// StatusReblog_Card defines model for StatusReblog.Card.
type StatusReblog_Card struct {
	union json.RawMessage
}

// StatusReblogPoll1 defines model for .
type StatusReblogPoll1 = map[string]interface{}

// StatusReblog_Poll defines model for StatusReblog.Poll.
type StatusReblog_Poll struct {
	union json.RawMessage
}

// StatusReblogVisibility Visibility of this status.
type StatusReblogVisibility string

// StatusTag defines model for StatusTag.
type StatusTag struct {
	// Name The value of the hashtag after the # sign.
	Name string `json:"name"`

	// Url A link to the hashtag on the instance.
	Url string `json:"url"`
}

// ArrayAllQueryParam defines model for ArrayAllQueryParam.
type ArrayAllQueryParam = []interface{}

// ArrayAnyQueryParam defines model for ArrayAnyQueryParam.
type ArrayAnyQueryParam = []interface{}

// ArrayNoneQueryParam defines model for ArrayNoneQueryParam.
type ArrayNoneQueryParam = []interface{}

// ExcludeReblogsQueryParam defines model for ExcludeReblogsQueryParam.
type ExcludeReblogsQueryParam = bool

// ExcludeRepliesQueryParam defines model for ExcludeRepliesQueryParam.
type ExcludeRepliesQueryParam = bool

// HashTagPathParam defines model for HashTagPathParam.
type HashTagPathParam = string

// IsLocalParam defines model for IsLocalParam.
type IsLocalParam = bool

// IsRemoteparam defines model for IsRemoteparam.
type IsRemoteparam = bool

// LimitQueryParam defines model for LimitQueryParam.
type LimitQueryParam = int

// MaxIdQueryParam defines model for MaxIdQueryParam.
type MaxIdQueryParam = string

// MinIdQueryParam defines model for MinIdQueryParam.
type MinIdQueryParam = string

// OnlyMediaQueryParam defines model for OnlyMediaQueryParam.
type OnlyMediaQueryParam = bool

// PinnedQueryParam defines model for PinnedQueryParam.
type PinnedQueryParam = bool

// SinceIdQueryParam defines model for SinceIdQueryParam.
type SinceIdQueryParam = string

// TaggedQueryParam defines model for TaggedQueryParam.
type TaggedQueryParam = string

// GetApiV1AccountsUidStatusesParams defines parameters for GetApiV1AccountsUidStatuses.
type GetApiV1AccountsUidStatusesParams struct {
	// MaxId Return results older than this ID
	MaxId *MaxIdQueryParam `form:"max_id,omitempty" json:"max_id,omitempty"`

	// SinceId Return results newer than this ID
	SinceId *SinceIdQueryParam `form:"since_id,omitempty" json:"since_id,omitempty"`

	// MinId Return results immediately newer than this ID
	MinId *MinIdQueryParam `form:"min_id,omitempty" json:"min_id,omitempty"`

	// Limit Maximum number of results to return. Defaults to 20 statuses. Max 40 statuses.
	Limit *LimitQueryParam `form:"limit,omitempty" json:"limit,omitempty"`

	// OnlyMedia Filter out statuses without attachments.
	OnlyMedia *OnlyMediaQueryParam `form:"only_media,omitempty" json:"only_media,omitempty"`

	// ExcludeReplies Filter out statuses in reply to a different account.
	ExcludeReplies *ExcludeRepliesQueryParam `form:"exclude_replies,omitempty" json:"exclude_replies,omitempty"`

	// ExcludeReblogs Filter out boosts from the response.
	ExcludeReblogs *ExcludeReblogsQueryParam `form:"exclude_reblogs,omitempty" json:"exclude_reblogs,omitempty"`

	// Pinned Filter for pinned statuses only.
	Pinned *PinnedQueryParam `form:"pinned,omitempty" json:"pinned,omitempty"`

	// Tagged Filter for statuses using a specific hashtag.
	Tagged *TaggedQueryParam `form:"tagged,omitempty" json:"tagged,omitempty"`
}

// GetApiV1TimelinesPublicParams defines parameters for GetApiV1TimelinesPublic.
type GetApiV1TimelinesPublicParams struct {
	// Local Boolean. Show only local statuses? Defaults to false.
	Local *IsLocalParam `form:"local,omitempty" json:"local,omitempty"`

	// Remote Boolean. Show only remote statuses? Defaults to false.
	Remote *IsRemoteparam `form:"remote,omitempty" json:"remote,omitempty"`

	// OnlyMedia Filter out statuses without attachments.
	OnlyMedia *OnlyMediaQueryParam `form:"only_media,omitempty" json:"only_media,omitempty"`

	// MaxId Return results older than this ID
	MaxId *MaxIdQueryParam `form:"max_id,omitempty" json:"max_id,omitempty"`

	// SinceId Return results newer than this ID
	SinceId *SinceIdQueryParam `form:"since_id,omitempty" json:"since_id,omitempty"`

	// MinId Return results immediately newer than this ID
	MinId *MinIdQueryParam `form:"min_id,omitempty" json:"min_id,omitempty"`

	// Limit Maximum number of results to return. Defaults to 20 statuses. Max 40 statuses.
	Limit *LimitQueryParam `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetApiV1TimelinesTagHashtagParams defines parameters for GetApiV1TimelinesTagHashtag.
type GetApiV1TimelinesTagHashtagParams struct {
	// Any Array of String. Return statuses that contain any of these additional tags.
	Any *ArrayAnyQueryParam `form:"any,omitempty" json:"any,omitempty"`

	// All Array of String. Return statuses that contain all of these additional tags.
	All *ArrayAllQueryParam `form:"all,omitempty" json:"all,omitempty"`

	// None Array of String. Return statuses that contain none of these additional tags.
	None *ArrayNoneQueryParam `form:"none,omitempty" json:"none,omitempty"`

	// Local Boolean. Show only local statuses? Defaults to false.
	Local *IsLocalParam `form:"local,omitempty" json:"local,omitempty"`

	// Remote Boolean. Show only remote statuses? Defaults to false.
	Remote *IsRemoteparam `form:"remote,omitempty" json:"remote,omitempty"`

	// OnlyMedia Filter out statuses without attachments.
	OnlyMedia *OnlyMediaQueryParam `form:"only_media,omitempty" json:"only_media,omitempty"`

	// MaxId Return results older than this ID
	MaxId *MaxIdQueryParam `form:"max_id,omitempty" json:"max_id,omitempty"`

	// SinceId Return results newer than this ID
	SinceId *SinceIdQueryParam `form:"since_id,omitempty" json:"since_id,omitempty"`

	// MinId Return results immediately newer than this ID
	MinId *MinIdQueryParam `form:"min_id,omitempty" json:"min_id,omitempty"`

	// Limit Maximum number of results to return. Defaults to 20 statuses. Max 40 statuses.
	Limit *LimitQueryParam `form:"limit,omitempty" json:"limit,omitempty"`
}

// AsPreviewCard returns the union data inside the Status_Card as a PreviewCard
func (t Status_Card) AsPreviewCard() (PreviewCard, error) {
	var body PreviewCard
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPreviewCard overwrites any union data inside the Status_Card as the provided PreviewCard
func (t *Status_Card) FromPreviewCard(v PreviewCard) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePreviewCard performs a merge with any union data inside the Status_Card, using the provided PreviewCard
func (t *Status_Card) MergePreviewCard(v PreviewCard) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsStatusCard1 returns the union data inside the Status_Card as a StatusCard1
func (t Status_Card) AsStatusCard1() (StatusCard1, error) {
	var body StatusCard1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStatusCard1 overwrites any union data inside the Status_Card as the provided StatusCard1
func (t *Status_Card) FromStatusCard1(v StatusCard1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStatusCard1 performs a merge with any union data inside the Status_Card, using the provided StatusCard1
func (t *Status_Card) MergeStatusCard1(v StatusCard1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t Status_Card) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Status_Card) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsPoll returns the union data inside the Status_Poll as a Poll
func (t Status_Poll) AsPoll() (Poll, error) {
	var body Poll
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPoll overwrites any union data inside the Status_Poll as the provided Poll
func (t *Status_Poll) FromPoll(v Poll) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePoll performs a merge with any union data inside the Status_Poll, using the provided Poll
func (t *Status_Poll) MergePoll(v Poll) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsStatusPoll1 returns the union data inside the Status_Poll as a StatusPoll1
func (t Status_Poll) AsStatusPoll1() (StatusPoll1, error) {
	var body StatusPoll1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStatusPoll1 overwrites any union data inside the Status_Poll as the provided StatusPoll1
func (t *Status_Poll) FromStatusPoll1(v StatusPoll1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStatusPoll1 performs a merge with any union data inside the Status_Poll, using the provided StatusPoll1
func (t *Status_Poll) MergeStatusPoll1(v StatusPoll1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t Status_Poll) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Status_Poll) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsStatusReblog returns the union data inside the Status_Reblog as a StatusReblog
func (t Status_Reblog) AsStatusReblog() (StatusReblog, error) {
	var body StatusReblog
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStatusReblog overwrites any union data inside the Status_Reblog as the provided StatusReblog
func (t *Status_Reblog) FromStatusReblog(v StatusReblog) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStatusReblog performs a merge with any union data inside the Status_Reblog, using the provided StatusReblog
func (t *Status_Reblog) MergeStatusReblog(v StatusReblog) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsStatusReblog1 returns the union data inside the Status_Reblog as a StatusReblog1
func (t Status_Reblog) AsStatusReblog1() (StatusReblog1, error) {
	var body StatusReblog1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStatusReblog1 overwrites any union data inside the Status_Reblog as the provided StatusReblog1
func (t *Status_Reblog) FromStatusReblog1(v StatusReblog1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStatusReblog1 performs a merge with any union data inside the Status_Reblog, using the provided StatusReblog1
func (t *Status_Reblog) MergeStatusReblog1(v StatusReblog1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t Status_Reblog) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Status_Reblog) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsPreviewCard returns the union data inside the StatusOrign_Card as a PreviewCard
func (t StatusOrign_Card) AsPreviewCard() (PreviewCard, error) {
	var body PreviewCard
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPreviewCard overwrites any union data inside the StatusOrign_Card as the provided PreviewCard
func (t *StatusOrign_Card) FromPreviewCard(v PreviewCard) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePreviewCard performs a merge with any union data inside the StatusOrign_Card, using the provided PreviewCard
func (t *StatusOrign_Card) MergePreviewCard(v PreviewCard) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsStatusOrignCard1 returns the union data inside the StatusOrign_Card as a StatusOrignCard1
func (t StatusOrign_Card) AsStatusOrignCard1() (StatusOrignCard1, error) {
	var body StatusOrignCard1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStatusOrignCard1 overwrites any union data inside the StatusOrign_Card as the provided StatusOrignCard1
func (t *StatusOrign_Card) FromStatusOrignCard1(v StatusOrignCard1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStatusOrignCard1 performs a merge with any union data inside the StatusOrign_Card, using the provided StatusOrignCard1
func (t *StatusOrign_Card) MergeStatusOrignCard1(v StatusOrignCard1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t StatusOrign_Card) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *StatusOrign_Card) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsPoll returns the union data inside the StatusOrign_Poll as a Poll
func (t StatusOrign_Poll) AsPoll() (Poll, error) {
	var body Poll
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPoll overwrites any union data inside the StatusOrign_Poll as the provided Poll
func (t *StatusOrign_Poll) FromPoll(v Poll) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePoll performs a merge with any union data inside the StatusOrign_Poll, using the provided Poll
func (t *StatusOrign_Poll) MergePoll(v Poll) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsStatusOrignPoll1 returns the union data inside the StatusOrign_Poll as a StatusOrignPoll1
func (t StatusOrign_Poll) AsStatusOrignPoll1() (StatusOrignPoll1, error) {
	var body StatusOrignPoll1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStatusOrignPoll1 overwrites any union data inside the StatusOrign_Poll as the provided StatusOrignPoll1
func (t *StatusOrign_Poll) FromStatusOrignPoll1(v StatusOrignPoll1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStatusOrignPoll1 performs a merge with any union data inside the StatusOrign_Poll, using the provided StatusOrignPoll1
func (t *StatusOrign_Poll) MergeStatusOrignPoll1(v StatusOrignPoll1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t StatusOrign_Poll) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *StatusOrign_Poll) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsPreviewCard returns the union data inside the StatusReblog_Card as a PreviewCard
func (t StatusReblog_Card) AsPreviewCard() (PreviewCard, error) {
	var body PreviewCard
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPreviewCard overwrites any union data inside the StatusReblog_Card as the provided PreviewCard
func (t *StatusReblog_Card) FromPreviewCard(v PreviewCard) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePreviewCard performs a merge with any union data inside the StatusReblog_Card, using the provided PreviewCard
func (t *StatusReblog_Card) MergePreviewCard(v PreviewCard) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsStatusReblogCard1 returns the union data inside the StatusReblog_Card as a StatusReblogCard1
func (t StatusReblog_Card) AsStatusReblogCard1() (StatusReblogCard1, error) {
	var body StatusReblogCard1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStatusReblogCard1 overwrites any union data inside the StatusReblog_Card as the provided StatusReblogCard1
func (t *StatusReblog_Card) FromStatusReblogCard1(v StatusReblogCard1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStatusReblogCard1 performs a merge with any union data inside the StatusReblog_Card, using the provided StatusReblogCard1
func (t *StatusReblog_Card) MergeStatusReblogCard1(v StatusReblogCard1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t StatusReblog_Card) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *StatusReblog_Card) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsPoll returns the union data inside the StatusReblog_Poll as a Poll
func (t StatusReblog_Poll) AsPoll() (Poll, error) {
	var body Poll
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPoll overwrites any union data inside the StatusReblog_Poll as the provided Poll
func (t *StatusReblog_Poll) FromPoll(v Poll) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePoll performs a merge with any union data inside the StatusReblog_Poll, using the provided Poll
func (t *StatusReblog_Poll) MergePoll(v Poll) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsStatusReblogPoll1 returns the union data inside the StatusReblog_Poll as a StatusReblogPoll1
func (t StatusReblog_Poll) AsStatusReblogPoll1() (StatusReblogPoll1, error) {
	var body StatusReblogPoll1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStatusReblogPoll1 overwrites any union data inside the StatusReblog_Poll as the provided StatusReblogPoll1
func (t *StatusReblog_Poll) FromStatusReblogPoll1(v StatusReblogPoll1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStatusReblogPoll1 performs a merge with any union data inside the StatusReblog_Poll, using the provided StatusReblogPoll1
func (t *StatusReblog_Poll) MergeStatusReblogPoll1(v StatusReblogPoll1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t StatusReblog_Poll) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *StatusReblog_Poll) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Verify account credentials
	// (GET /api/v1/accounts/verify_credentials)
	GetApiV1AccountsVerifyCredentials(ctx echo.Context) error
	// Get account
	// (GET /api/v1/accounts/{uid})
	GetApiV1AccountsUid(ctx echo.Context, uid string) error
	// Get account’s statuses
	// (GET /api/v1/accounts/{uid}/statuses)
	GetApiV1AccountsUidStatuses(ctx echo.Context, uid string, params GetApiV1AccountsUidStatusesParams) error
	// View public timeline
	// (GET /api/v1/timelines/public)
	GetApiV1TimelinesPublic(ctx echo.Context, params GetApiV1TimelinesPublicParams) error
	// View hashtag timeline
	// (GET /api/v1/timelines/tag/{hashtag})
	GetApiV1TimelinesTagHashtag(ctx echo.Context, hashtag HashTagPathParam, params GetApiV1TimelinesTagHashtagParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// GetApiV1AccountsVerifyCredentials converts echo context to params.
func (w *ServerInterfaceWrapper) GetApiV1AccountsVerifyCredentials(ctx echo.Context) error {
	var err error

	ctx.Set(NPubOrNSecScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetApiV1AccountsVerifyCredentials(ctx)
	return err
}

// GetApiV1AccountsUid converts echo context to params.
func (w *ServerInterfaceWrapper) GetApiV1AccountsUid(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "uid" -------------
	var uid string

	err = runtime.BindStyledParameterWithLocation("simple", false, "uid", runtime.ParamLocationPath, ctx.Param("uid"), &uid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter uid: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetApiV1AccountsUid(ctx, uid)
	return err
}

// GetApiV1AccountsUidStatuses converts echo context to params.
func (w *ServerInterfaceWrapper) GetApiV1AccountsUidStatuses(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "uid" -------------
	var uid string

	err = runtime.BindStyledParameterWithLocation("simple", false, "uid", runtime.ParamLocationPath, ctx.Param("uid"), &uid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter uid: %s", err))
	}

	ctx.Set(NPubOrNSecScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApiV1AccountsUidStatusesParams
	// ------------- Optional query parameter "max_id" -------------

	err = runtime.BindQueryParameter("form", true, false, "max_id", ctx.QueryParams(), &params.MaxId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max_id: %s", err))
	}

	// ------------- Optional query parameter "since_id" -------------

	err = runtime.BindQueryParameter("form", true, false, "since_id", ctx.QueryParams(), &params.SinceId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter since_id: %s", err))
	}

	// ------------- Optional query parameter "min_id" -------------

	err = runtime.BindQueryParameter("form", true, false, "min_id", ctx.QueryParams(), &params.MinId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min_id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "only_media" -------------

	err = runtime.BindQueryParameter("form", true, false, "only_media", ctx.QueryParams(), &params.OnlyMedia)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter only_media: %s", err))
	}

	// ------------- Optional query parameter "exclude_replies" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude_replies", ctx.QueryParams(), &params.ExcludeReplies)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude_replies: %s", err))
	}

	// ------------- Optional query parameter "exclude_reblogs" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude_reblogs", ctx.QueryParams(), &params.ExcludeReblogs)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude_reblogs: %s", err))
	}

	// ------------- Optional query parameter "pinned" -------------

	err = runtime.BindQueryParameter("form", true, false, "pinned", ctx.QueryParams(), &params.Pinned)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter pinned: %s", err))
	}

	// ------------- Optional query parameter "tagged" -------------

	err = runtime.BindQueryParameter("form", true, false, "tagged", ctx.QueryParams(), &params.Tagged)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tagged: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetApiV1AccountsUidStatuses(ctx, uid, params)
	return err
}

// GetApiV1TimelinesPublic converts echo context to params.
func (w *ServerInterfaceWrapper) GetApiV1TimelinesPublic(ctx echo.Context) error {
	var err error

	ctx.Set(NPubOrNSecScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApiV1TimelinesPublicParams
	// ------------- Optional query parameter "local" -------------

	err = runtime.BindQueryParameter("form", true, false, "local", ctx.QueryParams(), &params.Local)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter local: %s", err))
	}

	// ------------- Optional query parameter "remote" -------------

	err = runtime.BindQueryParameter("form", true, false, "remote", ctx.QueryParams(), &params.Remote)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter remote: %s", err))
	}

	// ------------- Optional query parameter "only_media" -------------

	err = runtime.BindQueryParameter("form", true, false, "only_media", ctx.QueryParams(), &params.OnlyMedia)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter only_media: %s", err))
	}

	// ------------- Optional query parameter "max_id" -------------

	err = runtime.BindQueryParameter("form", true, false, "max_id", ctx.QueryParams(), &params.MaxId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max_id: %s", err))
	}

	// ------------- Optional query parameter "since_id" -------------

	err = runtime.BindQueryParameter("form", true, false, "since_id", ctx.QueryParams(), &params.SinceId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter since_id: %s", err))
	}

	// ------------- Optional query parameter "min_id" -------------

	err = runtime.BindQueryParameter("form", true, false, "min_id", ctx.QueryParams(), &params.MinId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min_id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetApiV1TimelinesPublic(ctx, params)
	return err
}

// GetApiV1TimelinesTagHashtag converts echo context to params.
func (w *ServerInterfaceWrapper) GetApiV1TimelinesTagHashtag(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "hashtag" -------------
	var hashtag HashTagPathParam

	err = runtime.BindStyledParameterWithLocation("simple", false, "hashtag", runtime.ParamLocationPath, ctx.Param("hashtag"), &hashtag)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtag: %s", err))
	}

	ctx.Set(NPubOrNSecScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApiV1TimelinesTagHashtagParams
	// ------------- Optional query parameter "any" -------------

	err = runtime.BindQueryParameter("form", true, false, "any", ctx.QueryParams(), &params.Any)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter any: %s", err))
	}

	// ------------- Optional query parameter "all" -------------

	err = runtime.BindQueryParameter("form", true, false, "all", ctx.QueryParams(), &params.All)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter all: %s", err))
	}

	// ------------- Optional query parameter "none" -------------

	err = runtime.BindQueryParameter("form", true, false, "none", ctx.QueryParams(), &params.None)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter none: %s", err))
	}

	// ------------- Optional query parameter "local" -------------

	err = runtime.BindQueryParameter("form", true, false, "local", ctx.QueryParams(), &params.Local)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter local: %s", err))
	}

	// ------------- Optional query parameter "remote" -------------

	err = runtime.BindQueryParameter("form", true, false, "remote", ctx.QueryParams(), &params.Remote)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter remote: %s", err))
	}

	// ------------- Optional query parameter "only_media" -------------

	err = runtime.BindQueryParameter("form", true, false, "only_media", ctx.QueryParams(), &params.OnlyMedia)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter only_media: %s", err))
	}

	// ------------- Optional query parameter "max_id" -------------

	err = runtime.BindQueryParameter("form", true, false, "max_id", ctx.QueryParams(), &params.MaxId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max_id: %s", err))
	}

	// ------------- Optional query parameter "since_id" -------------

	err = runtime.BindQueryParameter("form", true, false, "since_id", ctx.QueryParams(), &params.SinceId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter since_id: %s", err))
	}

	// ------------- Optional query parameter "min_id" -------------

	err = runtime.BindQueryParameter("form", true, false, "min_id", ctx.QueryParams(), &params.MinId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min_id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetApiV1TimelinesTagHashtag(ctx, hashtag, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/api/v1/accounts/verify_credentials", wrapper.GetApiV1AccountsVerifyCredentials)
	router.GET(baseURL+"/api/v1/accounts/:uid", wrapper.GetApiV1AccountsUid)
	router.GET(baseURL+"/api/v1/accounts/:uid/statuses", wrapper.GetApiV1AccountsUidStatuses)
	router.GET(baseURL+"/api/v1/timelines/public", wrapper.GetApiV1TimelinesPublic)
	router.GET(baseURL+"/api/v1/timelines/tag/:hashtag", wrapper.GetApiV1TimelinesTagHashtag)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"/8aIeWsNnAAA",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
