// Package mopenapi provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.14.0 DO NOT EDIT.
package mopenapi

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"github.com/oapi-codegen/runtime"
)

const (
	NPubOrNSecScopes = "NPubOrNSec.Scopes"
)

// Defines values for FilterContext.
const (
	FilterContextAccount       FilterContext = "account"
	FilterContextHome          FilterContext = "home"
	FilterContextNotifications FilterContext = "notifications"
	FilterContextPublic        FilterContext = "public"
	FilterContextThread        FilterContext = "thread"
)

// Defines values for FilterFilterAction.
const (
	Hide FilterFilterAction = "hide"
	Warn FilterFilterAction = "warn"
)

// Defines values for MediaAttachmentType.
const (
	MediaAttachmentTypeAudio   MediaAttachmentType = "audio"
	MediaAttachmentTypeGif     MediaAttachmentType = "gif"
	MediaAttachmentTypeImage   MediaAttachmentType = "image"
	MediaAttachmentTypeUnknown MediaAttachmentType = "unknown"
	MediaAttachmentTypeVideo   MediaAttachmentType = "video"
)

// Defines values for PreviewCardType.
const (
	PreviewCardTypeLink  PreviewCardType = "link"
	PreviewCardTypePhoto PreviewCardType = "photo"
	PreviewCardTypeRich  PreviewCardType = "rich"
	PreviewCardTypeVideo PreviewCardType = "video"
)

// Defines values for SourcePrivacy.
const (
	SourcePrivacyDirect   SourcePrivacy = "direct"
	SourcePrivacyPrivate  SourcePrivacy = "private"
	SourcePrivacyPublic   SourcePrivacy = "public"
	SourcePrivacyUnlisted SourcePrivacy = "unlisted"
)

// Defines values for StatusVisibility.
const (
	StatusVisibilityDirect   StatusVisibility = "direct"
	StatusVisibilityPrivate  StatusVisibility = "private"
	StatusVisibilityPublic   StatusVisibility = "public"
	StatusVisibilityUnlisted StatusVisibility = "unlisted"
)

// Defines values for StatusOrignVisibility.
const (
	StatusOrignVisibilityDirect   StatusOrignVisibility = "direct"
	StatusOrignVisibilityPrivate  StatusOrignVisibility = "private"
	StatusOrignVisibilityPublic   StatusOrignVisibility = "public"
	StatusOrignVisibilityUnlisted StatusOrignVisibility = "unlisted"
)

// Defines values for StatusReblogVisibility.
const (
	Direct   StatusReblogVisibility = "direct"
	Private  StatusReblogVisibility = "private"
	Public   StatusReblogVisibility = "public"
	Unlisted StatusReblogVisibility = "unlisted"
)

// Account defines model for Account.
type Account struct {
	// Acct The Webfinger account URI. Equal to username for local users, or username@domain for remote users.
	Acct string `json:"acct"`

	// Avatar An image icon that is shown next to statuses and in the profile. (URL)
	Avatar string `json:"avatar"`

	// AvatarStatic A static version of the avatar. Equal to avatar if its value is a static image; different if avatar is an animated GIF.
	AvatarStatic string `json:"avatar_static"`

	// Bot Indicates that the account may perform automated actions, may not be monitored, or identifies
	Bot bool `json:"bot"`

	// CreatedAt When the account was created. (ISO 8601)
	CreatedAt string `json:"created_at"`

	// Discoverable Whether the account has opted into discovery features such as the profile directory.
	Discoverable *bool `json:"discoverable"`

	// DisplayName The profile’s display name.
	DisplayName string `json:"display_name"`

	// Emojis Custom emoji entities to be used when rendering the profile.
	Emojis []CustomEmoji `json:"emojis"`

	// Fields Custom emoji entities to be used when rendering the profile.
	Fields []Field `json:"fields"`

	// FollowersCount The reported followers of this profile.
	FollowersCount int `json:"followers_count"`

	// FollowingCount The reported follows of this profile.
	FollowingCount int `json:"following_count"`

	// Group Indicates that the account represents a Group actor.
	Group bool `json:"group"`

	// Header An image banner that is shown above the profile and in profile cards.
	Header string `json:"header"`

	// HeaderStatic A static version of the header. Equal to header if its value is a static image; different if header is an animated GIF.
	HeaderStatic string `json:"header_static"`

	// Id The account id.
	Id string `json:"id"`

	// LastStatusAt When the most recent status was posted. (ISO 8601)
	LastStatusAt *string `json:"last_status_at"`

	// Limited An extra attribute returned only when an account is silenced. If true, indicates that the account should be hidden behind a warning screen.
	Limited *bool `json:"limited,omitempty"`

	// Locked Whether the account manually approves follow requests.
	Locked bool `json:"locked"`

	// Moved Indicates that the profile is currently inactive and that its user has moved to a new account.
	Moved *bool `json:"moved"`

	// Noindex Whether the local user has opted out of being indexed by search engines.
	Noindex *bool `json:"noindex"`

	// Note The profile’s bio or description. (HTML)
	Note string `json:"note"`

	// StatusesCount How many statuses are attached to this account.
	StatusesCount int `json:"statuses_count"`

	// Suspended An extra attribute returned only when an account is suspended.
	Suspended *bool `json:"suspended,omitempty"`

	// Url The location of the user’s profile page.
	Url string `json:"url"`

	// Username The username of the account, not including domain.
	Username string `json:"username"`
}

// Application defines model for Application.
type Application struct {
	Name    *string `json:"name"`
	Website *string `json:"website"`
}

// CredentialAccount defines model for CredentialAccount.
type CredentialAccount struct {
	// Acct The Webfinger account URI. Equal to username for local users, or username@domain for remote users.
	Acct string `json:"acct"`

	// Avatar An image icon that is shown next to statuses and in the profile. (URL)
	Avatar string `json:"avatar"`

	// AvatarStatic A static version of the avatar. Equal to avatar if its value is a static image; different if avatar is an animated GIF.
	AvatarStatic string `json:"avatar_static"`

	// Bot Indicates that the account may perform automated actions, may not be monitored, or identifies
	Bot bool `json:"bot"`

	// CreatedAt When the account was created. (ISO 8601)
	CreatedAt string `json:"created_at"`

	// Discoverable Whether the account has opted into discovery features such as the profile directory.
	Discoverable *bool `json:"discoverable"`

	// DisplayName The profile’s display name.
	DisplayName string `json:"display_name"`

	// Emojis Custom emoji entities to be used when rendering the profile.
	Emojis []CustomEmoji `json:"emojis"`

	// Fields Custom emoji entities to be used when rendering the profile.
	Fields []Field `json:"fields"`

	// FollowersCount The reported followers of this profile.
	FollowersCount int `json:"followers_count"`

	// FollowingCount The reported follows of this profile.
	FollowingCount int `json:"following_count"`

	// Group Indicates that the account represents a Group actor.
	Group bool `json:"group"`

	// Header An image banner that is shown above the profile and in profile cards.
	Header string `json:"header"`

	// HeaderStatic A static version of the header. Equal to header if its value is a static image; different if header is an animated GIF.
	HeaderStatic string `json:"header_static"`

	// Id The account id.
	Id string `json:"id"`

	// LastStatusAt When the most recent status was posted. (ISO 8601)
	LastStatusAt *string `json:"last_status_at"`

	// Limited An extra attribute returned only when an account is silenced. If true, indicates that the account should be hidden behind a warning screen.
	Limited *bool `json:"limited,omitempty"`

	// Locked Whether the account manually approves follow requests.
	Locked bool `json:"locked"`

	// Moved Indicates that the profile is currently inactive and that its user has moved to a new account.
	Moved *bool `json:"moved"`

	// Noindex Whether the local user has opted out of being indexed by search engines.
	Noindex *bool `json:"noindex"`

	// Note The profile’s bio or description. (HTML)
	Note   string `json:"note"`
	Role   Role   `json:"role"`
	Source Source `json:"source"`

	// StatusesCount How many statuses are attached to this account.
	StatusesCount int `json:"statuses_count"`

	// Suspended An extra attribute returned only when an account is suspended.
	Suspended *bool `json:"suspended,omitempty"`

	// Url The location of the user’s profile page.
	Url string `json:"url"`

	// Username The username of the account, not including domain.
	Username string `json:"username"`
}

// CustomEmoji defines model for CustomEmoji.
type CustomEmoji struct {
	// Category Used for sorting custom emoji in the picker.
	Category string `json:"category"`

	// Shortcode The name of the custom emoji.
	Shortcode string `json:"shortcode"`

	// StaticUrl A link to a static copy of the custom emoji.
	StaticUrl string `json:"static_url"`

	// Url A link to the custom emoji.
	Url string `json:"url"`

	// VisibleInPicker Whether this Emoji should be visible in the picker or unlisted.
	VisibleInPicker bool `json:"visible_in_picker"`
}

// Field defines model for Field.
type Field struct {
	// Name The key of a given field’s key-value pair.
	Name string `json:"name"`

	// Value The value associated with the name key.
	Value string `json:"value"`

	// VerifiedAt Timestamp of when the server verified a URL value for a rel=“me” link.
	VerifiedAt *string `json:"verified_at"`
}

// Filter Represents a user-defined filter for determining which statuses should not be shown to the user.
type Filter struct {
	// Context The contexts in which the filter should be applied.
	Context []FilterContext `json:"context"`

	// ExpiresAt When the filter should no longer be applied.
	ExpiresAt *string `json:"expires_at"`

	// FilterAction The action to be taken when a status matches this filter.
	FilterAction FilterFilterAction `json:"filter_action"`

	// Id The ID of the Filter in the database.
	Id string `json:"id"`

	// Keywords The keywords grouped under this filter.
	Keywords []FilterKeyword `json:"keywords"`

	// Statuses The statuses grouped under this filter.
	Statuses []FilterStatus `json:"statuses"`

	// Title A title given by the user to name the filter.
	Title string `json:"title"`
}

// FilterContext defines model for Filter.Context.
type FilterContext string

// FilterFilterAction The action to be taken when a status matches this filter.
type FilterFilterAction string

// FilterKeyword Represents a keyword that, if matched, should cause the filter action to be taken.
type FilterKeyword struct {
	// Id The ID of the FilterKeyword in the database.
	Id string `json:"id"`

	// Keyword The phrase to be matched against.
	Keyword string `json:"keyword"`

	// WholeWord Should the filter consider word boundaries? See implementation guidelines for filters.
	WholeWord bool `json:"whole_word"`
}

// FilterResult Represents a filter whose keywords matched a given status.
type FilterResult struct {
	// Filter Represents a user-defined filter for determining which statuses should not be shown to the user.
	Filter Filter `json:"filter"`

	// KeywordMatches The keyword within the filter that was matched.
	KeywordMatches *[]string `json:"keyword_matches"`

	// StatusMatches The status ID within the filter that was matched.
	StatusMatches *[]string `json:"status_matches"`
}

// FilterStatus Represents a status ID that, if matched, should cause the filter action to be taken.
type FilterStatus struct {
	// Id The ID of the FilterStatus in the database.
	Id string `json:"id"`

	// StatusId The ID of the Status that will be filtered.
	StatusId string `json:"status_id"`
}

// MediaAttachment defines model for MediaAttachment.
type MediaAttachment struct {
	// Blurhash A hash computed by the BlurHash algorithm, for generating colorful preview thumbnails when media has not been downloaded yet.
	Blurhash string `json:"blurhash"`

	// Description Alternate text that describes what is in the media attachment, to be used for the visually impaired or when media attachments do not load.
	Description string `json:"description"`

	// Id The ID of the attachment in the database.
	Id   string         `json:"id"`
	Meta MediaImegeMeta `json:"meta"`

	// PreviewUrl The location of a scaled-down preview of the attachment.
	PreviewUrl string `json:"preview_url"`

	// RemoteUrl The location of the full-size original attachment on the remote website.
	RemoteUrl *string `json:"remote_url"`

	// Type The type of the attachment.
	Type MediaAttachmentType `json:"type"`

	// Url The location of the original full-size attachment.
	Url string `json:"url"`
}

// MediaAttachmentType The type of the attachment.
type MediaAttachmentType string

// MediaImageForcus defines model for MediaImageForcus.
type MediaImageForcus struct {
	X *float32 `json:"x,omitempty"`
	Y *float32 `json:"y,omitempty"`
}

// MediaImageSize defines model for MediaImageSize.
type MediaImageSize struct {
	Aspect *float32 `json:"aspect,omitempty"`
	Height *int     `json:"height,omitempty"`
	Size   *string  `json:"size,omitempty"`
	Width  *int     `json:"width,omitempty"`
}

// MediaImegeMeta defines model for MediaImegeMeta.
type MediaImegeMeta struct {
	Focus    *MediaImageForcus `json:"focus,omitempty"`
	Original *MediaImageSize   `json:"original,omitempty"`
	Small    *MediaImageSize   `json:"small,omitempty"`
}

// Poll Represents a poll attached to a status.
type Poll struct {
	// Emojis Custom emoji to be used for rendering poll options.
	Emojis []CustomEmoji `json:"emojis"`

	// Expired Is the poll currently expired?
	Expired bool `json:"expired"`

	// ExpiresAt When the poll ends.
	ExpiresAt *string `json:"expires_at"`

	// Id The ID of the poll in the database.
	Id string `json:"id"`

	// Multiple Does the poll allow multiple-choice answers?
	Multiple bool `json:"multiple"`

	// Options Possible answers for the poll.
	Options []PollOption `json:"options"`

	// OwnVotes When called with a user token, which options has the authorized user chosen? Contains an array of index values for options.
	OwnVotes *[]int `json:"own_votes,omitempty"`

	// Voted When called with a user token, has the authorized user voted?
	Voted *bool `json:"voted,omitempty"`

	// VotersCount How many unique accounts have voted on a multiple-choice poll.
	VotersCount *int `json:"voters_count"`

	// VotesCount How many votes have been received.
	VotesCount int `json:"votes_count"`
}

// PollOption defines model for PollOption.
type PollOption struct {
	// Title The text value of the poll option.
	Title string `json:"title"`

	// VotesCount The total number of received votes for this option.
	VotesCount *int `json:"votes_count"`
}

// PreviewCard Represents a rich preview card that is generated using OpenGraph tags from a URL.
type PreviewCard struct {
	// AuthorName The author of the original resource.
	AuthorName string `json:"author_name"`

	// AuthorUrl A link to the author of the original resource.
	AuthorUrl string `json:"author_url"`

	// Blurhash A hash computed by the BlurHash algorithm, for generating colorful preview thumbnails when media has not been downloaded yet.
	Blurhash *string `json:"blurhash"`

	// Description Description of preview.
	Description string `json:"description"`

	// EmbedUrl Used for photo embeds, instead of custom html.
	EmbedUrl string `json:"embed_url"`

	// Height Height of preview, in pixels.
	Height int `json:"height"`

	// Html HTML to be used for generating the preview card.
	Html string `json:"html"`

	// Image Preview thumbnail.
	Image *string `json:"image"`

	// ProviderName The provider of the original resource.
	ProviderName string `json:"provider_name"`

	// ProviderUrl A link to the provider of the original resource.
	ProviderUrl string `json:"provider_url"`

	// Title Title of linked resource.
	Title string `json:"title"`

	// Type The type of the preview card.
	Type PreviewCardType `json:"type"`

	// Url Location of linked resource.
	Url string `json:"url"`

	// Width Width of preview, in pixels.
	Width int `json:"width"`
}

// PreviewCardType The type of the preview card.
type PreviewCardType string

// Role defines model for Role.
type Role struct {
	// Color The hex code assigned to this role. If no hex code is assigned, the string will be empty.
	Color string `json:"color"`

	// Highlighted  Whether the role is publicly visible as a badge on user profiles.
	Highlighted bool `json:"highlighted"`

	// Id The ID of the Role in the database.
	Id int `json:"id"`

	// Name The name of the role.
	Name string `json:"name"`

	// Permissions A bitmask that represents the sum of all permissions granted to the role.
	Permissions int `json:"permissions"`
}

// Source defines model for Source.
type Source struct {
	// Fields Metadata about the account.
	Fields []Field `json:"fields"`

	// FollowRequestsCount The number of pending follow requests.
	FollowRequestsCount int `json:"follow_requests_count"`

	// Language The default posting language for new statuses. (ISO 639-1 language two-letter code) or empty string.
	Language string `json:"language"`

	// Note Profile bio, in plain-text instead of in HTML.
	Note string `json:"note"`

	// Privacy The default post privacy to be used for new statuses.
	Privacy SourcePrivacy `json:"privacy"`

	// Sensitive Whether new statuses should be marked sensitive by default.
	Sensitive bool `json:"sensitive"`
}

// SourcePrivacy The default post privacy to be used for new statuses.
type SourcePrivacy string

// Status defines model for Status.
type Status struct {
	Account     Account      `json:"account"`
	Application *Application `json:"application,omitempty"`

	// Bookmarked If the current token has an authorized user: Have you bookmarked this status?
	Bookmarked *bool       `json:"bookmarked,omitempty"`
	Card       Status_Card `json:"card"`

	// Content HTML-encoded status content.
	Content string `json:"content"`

	// CreatedAt The date when this status was created.
	CreatedAt string `json:"created_at"`

	// EditedAt Timestamp of when the status was last edited.
	EditedAt *string `json:"edited_at"`

	// Emojis Custom emoji to be used when rendering status content.
	Emojis []CustomEmoji `json:"emojis"`

	// Favourited If the current token has an authorized user: Have you favourited this status?
	Favourited *bool `json:"favourited,omitempty"`

	// FavouritesCount How many favourites this status has received.
	FavouritesCount int `json:"favourites_count"`

	// Filtered If the current token has an authorized user: The filter and keywords that matched this status.
	Filtered *[]FilterResult `json:"filtered,omitempty"`

	// Id ID of the status in the database.
	Id string `json:"id"`

	// InReplyToAccountId ID of the account that authored the status being replied to.
	InReplyToAccountId *string `json:"in_reply_to_account_id"`

	// InReplyToId ID of the status being replied to.
	InReplyToId *string `json:"in_reply_to_id"`

	// Language Primary language of this status.
	Language *string `json:"language"`

	// MediaAttachments Media that is attached to this status.
	MediaAttachments []MediaAttachment `json:"media_attachments"`

	// Mentions Mentions of users within the status content.
	Mentions []StatusMention `json:"mentions"`

	// Muted If the current token has an authorized user: Have you muted notifications for this status’s conversation?
	Muted *bool `json:"muted,omitempty"`

	// Pinned If the current token has an authorized user: Have you pinned this status? Only appears if the status is pinnable.
	Pinned *bool       `json:"pinned,omitempty"`
	Poll   Status_Poll `json:"poll"`

	// Reblog The status being reblogged.
	Reblog Status_Reblog `json:"reblog"`

	// Reblogged If the current token has an authorized user: Have you boosted this status?
	Reblogged *bool `json:"reblogged,omitempty"`

	// ReblogsCount How many boosts this status has received.
	ReblogsCount int `json:"reblogs_count"`

	// RepliesCount How many replies this status has received.
	RepliesCount int `json:"replies_count"`

	// Sensitive Is this status marked as sensitive content?
	Sensitive bool `json:"sensitive"`

	// SpoilerText Subject or summary line, below which status content is collapsed until expanded.
	SpoilerText string `json:"spoiler_text"`

	// Tags Hashtags used within the status content.
	Tags []StatusTag `json:"tags"`

	// Text Plain-text source of a status. Returned instead of content when status is deleted, so the user may redraft from the source text without the client having to reverse-engineer the original text from the HTML content.
	Text *string `json:"text"`

	// Uri URI of the status used for federation.
	Uri string `json:"uri"`

	// Url A link to the status’s HTML representation.
	Url *string `json:"url"`

	// Visibility Visibility of this status.
	Visibility StatusVisibility `json:"visibility"`
}

// StatusCard1 defines model for .
type StatusCard1 = map[string]interface{}

// Status_Card defines model for Status.Card.
type Status_Card struct {
	union json.RawMessage
}

// StatusPoll1 defines model for .
type StatusPoll1 = map[string]interface{}

// Status_Poll defines model for Status.Poll.
type Status_Poll struct {
	union json.RawMessage
}

// StatusReblog1 defines model for .
type StatusReblog1 = map[string]interface{}

// Status_Reblog The status being reblogged.
type Status_Reblog struct {
	union json.RawMessage
}

// StatusVisibility Visibility of this status.
type StatusVisibility string

// StatusMention defines model for StatusMention.
type StatusMention struct {
	// Acct The webfinger acct: URI of the mentioned user. Equivalent to username for local users, or username@domain for remote users.
	Acct string `json:"acct"`

	// Id The account ID of the mentioned user.
	Id string `json:"id"`

	// Url The location of the mentioned user’s profile.
	Url string `json:"url"`

	// Username The username of the mentioned user.
	Username string `json:"username"`
}

// StatusOrign Represents a status posted by an account.
type StatusOrign struct {
	Account     Account      `json:"account"`
	Application *Application `json:"application,omitempty"`

	// Bookmarked If the current token has an authorized user: Have you bookmarked this status?
	Bookmarked *bool            `json:"bookmarked,omitempty"`
	Card       StatusOrign_Card `json:"card"`

	// Content HTML-encoded status content.
	Content string `json:"content"`

	// CreatedAt The date when this status was created.
	CreatedAt string `json:"created_at"`

	// EditedAt Timestamp of when the status was last edited.
	EditedAt *string `json:"edited_at"`

	// Emojis Custom emoji to be used when rendering status content.
	Emojis []CustomEmoji `json:"emojis"`

	// Favourited If the current token has an authorized user: Have you favourited this status?
	Favourited *bool `json:"favourited,omitempty"`

	// FavouritesCount How many favourites this status has received.
	FavouritesCount int `json:"favourites_count"`

	// Filtered If the current token has an authorized user: The filter and keywords that matched this status.
	Filtered *[]FilterResult `json:"filtered,omitempty"`

	// Id ID of the status in the database.
	Id string `json:"id"`

	// InReplyToAccountId ID of the account that authored the status being replied to.
	InReplyToAccountId *string `json:"in_reply_to_account_id"`

	// InReplyToId ID of the status being replied to.
	InReplyToId *string `json:"in_reply_to_id"`

	// Language Primary language of this status.
	Language *string `json:"language"`

	// MediaAttachments Media that is attached to this status.
	MediaAttachments []MediaAttachment `json:"media_attachments"`

	// Mentions Mentions of users within the status content.
	Mentions []StatusMention `json:"mentions"`

	// Muted If the current token has an authorized user: Have you muted notifications for this status’s conversation?
	Muted *bool `json:"muted,omitempty"`

	// Pinned If the current token has an authorized user: Have you pinned this status? Only appears if the status is pinnable.
	Pinned *bool            `json:"pinned,omitempty"`
	Poll   StatusOrign_Poll `json:"poll"`

	// Reblogged If the current token has an authorized user: Have you boosted this status?
	Reblogged *bool `json:"reblogged,omitempty"`

	// ReblogsCount How many boosts this status has received.
	ReblogsCount int `json:"reblogs_count"`

	// RepliesCount How many replies this status has received.
	RepliesCount int `json:"replies_count"`

	// Sensitive Is this status marked as sensitive content?
	Sensitive bool `json:"sensitive"`

	// SpoilerText Subject or summary line, below which status content is collapsed until expanded.
	SpoilerText string `json:"spoiler_text"`

	// Tags Hashtags used within the status content.
	Tags []StatusTag `json:"tags"`

	// Text Plain-text source of a status. Returned instead of content when status is deleted, so the user may redraft from the source text without the client having to reverse-engineer the original text from the HTML content.
	Text *string `json:"text"`

	// Uri URI of the status used for federation.
	Uri string `json:"uri"`

	// Url A link to the status’s HTML representation.
	Url *string `json:"url"`

	// Visibility Visibility of this status.
	Visibility StatusOrignVisibility `json:"visibility"`
}

// StatusOrignCard1 defines model for .
type StatusOrignCard1 = map[string]interface{}

// StatusOrign_Card defines model for StatusOrign.Card.
type StatusOrign_Card struct {
	union json.RawMessage
}

// StatusOrignPoll1 defines model for .
type StatusOrignPoll1 = map[string]interface{}

// StatusOrign_Poll defines model for StatusOrign.Poll.
type StatusOrign_Poll struct {
	union json.RawMessage
}

// StatusOrignVisibility Visibility of this status.
type StatusOrignVisibility string

// StatusReblog defines model for StatusReblog.
type StatusReblog struct {
	Account     Account      `json:"account"`
	Application *Application `json:"application,omitempty"`

	// Bookmarked If the current token has an authorized user: Have you bookmarked this status?
	Bookmarked *bool             `json:"bookmarked,omitempty"`
	Card       StatusReblog_Card `json:"card"`

	// Content HTML-encoded status content.
	Content string `json:"content"`

	// CreatedAt The date when this status was created.
	CreatedAt string `json:"created_at"`

	// EditedAt Timestamp of when the status was last edited.
	EditedAt *string `json:"edited_at"`

	// Emojis Custom emoji to be used when rendering status content.
	Emojis []CustomEmoji `json:"emojis"`

	// Favourited If the current token has an authorized user: Have you favourited this status?
	Favourited *bool `json:"favourited,omitempty"`

	// FavouritesCount How many favourites this status has received.
	FavouritesCount int `json:"favourites_count"`

	// Filtered If the current token has an authorized user: The filter and keywords that matched this status.
	Filtered *[]FilterResult `json:"filtered,omitempty"`

	// Id ID of the status in the database.
	Id string `json:"id"`

	// InReplyToAccountId ID of the account that authored the status being replied to.
	InReplyToAccountId *string `json:"in_reply_to_account_id"`

	// InReplyToId ID of the status being replied to.
	InReplyToId *string `json:"in_reply_to_id"`

	// Language Primary language of this status.
	Language *string `json:"language"`

	// MediaAttachments Media that is attached to this status.
	MediaAttachments []MediaAttachment `json:"media_attachments"`

	// Mentions Mentions of users within the status content.
	Mentions []StatusMention `json:"mentions"`

	// Muted If the current token has an authorized user: Have you muted notifications for this status’s conversation?
	Muted *bool `json:"muted,omitempty"`

	// Pinned If the current token has an authorized user: Have you pinned this status? Only appears if the status is pinnable.
	Pinned *bool                   `json:"pinned,omitempty"`
	Poll   StatusReblog_Poll       `json:"poll"`
	Reblog *map[string]interface{} `json:"reblog"`

	// Reblogged If the current token has an authorized user: Have you boosted this status?
	Reblogged *bool `json:"reblogged,omitempty"`

	// ReblogsCount How many boosts this status has received.
	ReblogsCount int `json:"reblogs_count"`

	// RepliesCount How many replies this status has received.
	RepliesCount int `json:"replies_count"`

	// Sensitive Is this status marked as sensitive content?
	Sensitive bool `json:"sensitive"`

	// SpoilerText Subject or summary line, below which status content is collapsed until expanded.
	SpoilerText string `json:"spoiler_text"`

	// Tags Hashtags used within the status content.
	Tags []StatusTag `json:"tags"`

	// Text Plain-text source of a status. Returned instead of content when status is deleted, so the user may redraft from the source text without the client having to reverse-engineer the original text from the HTML content.
	Text *string `json:"text"`

	// Uri URI of the status used for federation.
	Uri string `json:"uri"`

	// Url A link to the status’s HTML representation.
	Url *string `json:"url"`

	// Visibility Visibility of this status.
	Visibility StatusReblogVisibility `json:"visibility"`
}

// StatusReblogCard1 defines model for .
type StatusReblogCard1 = map[string]interface{}

// StatusReblog_Card defines model for StatusReblog.Card.
type StatusReblog_Card struct {
	union json.RawMessage
}

// StatusReblogPoll1 defines model for .
type StatusReblogPoll1 = map[string]interface{}

// StatusReblog_Poll defines model for StatusReblog.Poll.
type StatusReblog_Poll struct {
	union json.RawMessage
}

// StatusReblogVisibility Visibility of this status.
type StatusReblogVisibility string

// StatusTag defines model for StatusTag.
type StatusTag struct {
	// Name The value of the hashtag after the # sign.
	Name string `json:"name"`

	// Url A link to the hashtag on the instance.
	Url string `json:"url"`
}

// ExcludeReblogsQueryParam defines model for ExcludeReblogsQueryParam.
type ExcludeReblogsQueryParam = bool

// ExcludeRepliesQueryParam defines model for ExcludeRepliesQueryParam.
type ExcludeRepliesQueryParam = bool

// IsLocalParam defines model for IsLocalParam.
type IsLocalParam = bool

// IsRemoteparam defines model for IsRemoteparam.
type IsRemoteparam = bool

// LimitQueryParam defines model for LimitQueryParam.
type LimitQueryParam = int

// MaxIdQueryParam defines model for MaxIdQueryParam.
type MaxIdQueryParam = string

// MinIdQueryParam defines model for MinIdQueryParam.
type MinIdQueryParam = string

// OnlyMediaQueryParam defines model for OnlyMediaQueryParam.
type OnlyMediaQueryParam = bool

// PinnedQueryParam defines model for PinnedQueryParam.
type PinnedQueryParam = bool

// SinceIdQueryParam defines model for SinceIdQueryParam.
type SinceIdQueryParam = string

// TaggedQueryParam defines model for TaggedQueryParam.
type TaggedQueryParam = string

// GetApiV1AccountsUidStatusesParams defines parameters for GetApiV1AccountsUidStatuses.
type GetApiV1AccountsUidStatusesParams struct {
	// MaxId Return results older than this ID
	MaxId *MaxIdQueryParam `form:"max_id,omitempty" json:"max_id,omitempty"`

	// SinceId Return results newer than this ID
	SinceId *SinceIdQueryParam `form:"since_id,omitempty" json:"since_id,omitempty"`

	// MinId Return results immediately newer than this ID
	MinId *MinIdQueryParam `form:"min_id,omitempty" json:"min_id,omitempty"`

	// Limit Maximum number of results to return. Defaults to 20 statuses. Max 40 statuses.
	Limit *LimitQueryParam `form:"limit,omitempty" json:"limit,omitempty"`

	// OnlyMedia Filter out statuses without attachments.
	OnlyMedia *OnlyMediaQueryParam `form:"only_media,omitempty" json:"only_media,omitempty"`

	// ExcludeReplies Filter out statuses in reply to a different account.
	ExcludeReplies *ExcludeRepliesQueryParam `form:"exclude_replies,omitempty" json:"exclude_replies,omitempty"`

	// ExcludeReblogs Filter out boosts from the response.
	ExcludeReblogs *ExcludeReblogsQueryParam `form:"exclude_reblogs,omitempty" json:"exclude_reblogs,omitempty"`

	// Pinned Filter for pinned statuses only.
	Pinned *PinnedQueryParam `form:"pinned,omitempty" json:"pinned,omitempty"`

	// Tagged Filter for statuses using a specific hashtag.
	Tagged *TaggedQueryParam `form:"tagged,omitempty" json:"tagged,omitempty"`
}

// GetApiV1TimelinesPublicParams defines parameters for GetApiV1TimelinesPublic.
type GetApiV1TimelinesPublicParams struct {
	// Local Boolean. Show only local statuses? Defaults to false.
	Local *IsLocalParam `form:"local,omitempty" json:"local,omitempty"`

	// Remote Boolean. Show only remote statuses? Defaults to false.
	Remote *IsRemoteparam `form:"remote,omitempty" json:"remote,omitempty"`

	// OnlyMedia Filter out statuses without attachments.
	OnlyMedia *OnlyMediaQueryParam `form:"only_media,omitempty" json:"only_media,omitempty"`

	// MaxId Return results older than this ID
	MaxId *MaxIdQueryParam `form:"max_id,omitempty" json:"max_id,omitempty"`

	// SinceId Return results newer than this ID
	SinceId *SinceIdQueryParam `form:"since_id,omitempty" json:"since_id,omitempty"`

	// MinId Return results immediately newer than this ID
	MinId *MinIdQueryParam `form:"min_id,omitempty" json:"min_id,omitempty"`

	// Limit Maximum number of results to return. Defaults to 20 statuses. Max 40 statuses.
	Limit *LimitQueryParam `form:"limit,omitempty" json:"limit,omitempty"`
}

// AsPreviewCard returns the union data inside the Status_Card as a PreviewCard
func (t Status_Card) AsPreviewCard() (PreviewCard, error) {
	var body PreviewCard
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPreviewCard overwrites any union data inside the Status_Card as the provided PreviewCard
func (t *Status_Card) FromPreviewCard(v PreviewCard) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePreviewCard performs a merge with any union data inside the Status_Card, using the provided PreviewCard
func (t *Status_Card) MergePreviewCard(v PreviewCard) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsStatusCard1 returns the union data inside the Status_Card as a StatusCard1
func (t Status_Card) AsStatusCard1() (StatusCard1, error) {
	var body StatusCard1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStatusCard1 overwrites any union data inside the Status_Card as the provided StatusCard1
func (t *Status_Card) FromStatusCard1(v StatusCard1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStatusCard1 performs a merge with any union data inside the Status_Card, using the provided StatusCard1
func (t *Status_Card) MergeStatusCard1(v StatusCard1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t Status_Card) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Status_Card) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsPoll returns the union data inside the Status_Poll as a Poll
func (t Status_Poll) AsPoll() (Poll, error) {
	var body Poll
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPoll overwrites any union data inside the Status_Poll as the provided Poll
func (t *Status_Poll) FromPoll(v Poll) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePoll performs a merge with any union data inside the Status_Poll, using the provided Poll
func (t *Status_Poll) MergePoll(v Poll) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsStatusPoll1 returns the union data inside the Status_Poll as a StatusPoll1
func (t Status_Poll) AsStatusPoll1() (StatusPoll1, error) {
	var body StatusPoll1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStatusPoll1 overwrites any union data inside the Status_Poll as the provided StatusPoll1
func (t *Status_Poll) FromStatusPoll1(v StatusPoll1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStatusPoll1 performs a merge with any union data inside the Status_Poll, using the provided StatusPoll1
func (t *Status_Poll) MergeStatusPoll1(v StatusPoll1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t Status_Poll) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Status_Poll) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsStatusReblog returns the union data inside the Status_Reblog as a StatusReblog
func (t Status_Reblog) AsStatusReblog() (StatusReblog, error) {
	var body StatusReblog
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStatusReblog overwrites any union data inside the Status_Reblog as the provided StatusReblog
func (t *Status_Reblog) FromStatusReblog(v StatusReblog) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStatusReblog performs a merge with any union data inside the Status_Reblog, using the provided StatusReblog
func (t *Status_Reblog) MergeStatusReblog(v StatusReblog) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsStatusReblog1 returns the union data inside the Status_Reblog as a StatusReblog1
func (t Status_Reblog) AsStatusReblog1() (StatusReblog1, error) {
	var body StatusReblog1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStatusReblog1 overwrites any union data inside the Status_Reblog as the provided StatusReblog1
func (t *Status_Reblog) FromStatusReblog1(v StatusReblog1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStatusReblog1 performs a merge with any union data inside the Status_Reblog, using the provided StatusReblog1
func (t *Status_Reblog) MergeStatusReblog1(v StatusReblog1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t Status_Reblog) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Status_Reblog) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsPreviewCard returns the union data inside the StatusOrign_Card as a PreviewCard
func (t StatusOrign_Card) AsPreviewCard() (PreviewCard, error) {
	var body PreviewCard
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPreviewCard overwrites any union data inside the StatusOrign_Card as the provided PreviewCard
func (t *StatusOrign_Card) FromPreviewCard(v PreviewCard) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePreviewCard performs a merge with any union data inside the StatusOrign_Card, using the provided PreviewCard
func (t *StatusOrign_Card) MergePreviewCard(v PreviewCard) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsStatusOrignCard1 returns the union data inside the StatusOrign_Card as a StatusOrignCard1
func (t StatusOrign_Card) AsStatusOrignCard1() (StatusOrignCard1, error) {
	var body StatusOrignCard1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStatusOrignCard1 overwrites any union data inside the StatusOrign_Card as the provided StatusOrignCard1
func (t *StatusOrign_Card) FromStatusOrignCard1(v StatusOrignCard1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStatusOrignCard1 performs a merge with any union data inside the StatusOrign_Card, using the provided StatusOrignCard1
func (t *StatusOrign_Card) MergeStatusOrignCard1(v StatusOrignCard1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t StatusOrign_Card) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *StatusOrign_Card) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsPoll returns the union data inside the StatusOrign_Poll as a Poll
func (t StatusOrign_Poll) AsPoll() (Poll, error) {
	var body Poll
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPoll overwrites any union data inside the StatusOrign_Poll as the provided Poll
func (t *StatusOrign_Poll) FromPoll(v Poll) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePoll performs a merge with any union data inside the StatusOrign_Poll, using the provided Poll
func (t *StatusOrign_Poll) MergePoll(v Poll) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsStatusOrignPoll1 returns the union data inside the StatusOrign_Poll as a StatusOrignPoll1
func (t StatusOrign_Poll) AsStatusOrignPoll1() (StatusOrignPoll1, error) {
	var body StatusOrignPoll1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStatusOrignPoll1 overwrites any union data inside the StatusOrign_Poll as the provided StatusOrignPoll1
func (t *StatusOrign_Poll) FromStatusOrignPoll1(v StatusOrignPoll1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStatusOrignPoll1 performs a merge with any union data inside the StatusOrign_Poll, using the provided StatusOrignPoll1
func (t *StatusOrign_Poll) MergeStatusOrignPoll1(v StatusOrignPoll1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t StatusOrign_Poll) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *StatusOrign_Poll) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsPreviewCard returns the union data inside the StatusReblog_Card as a PreviewCard
func (t StatusReblog_Card) AsPreviewCard() (PreviewCard, error) {
	var body PreviewCard
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPreviewCard overwrites any union data inside the StatusReblog_Card as the provided PreviewCard
func (t *StatusReblog_Card) FromPreviewCard(v PreviewCard) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePreviewCard performs a merge with any union data inside the StatusReblog_Card, using the provided PreviewCard
func (t *StatusReblog_Card) MergePreviewCard(v PreviewCard) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsStatusReblogCard1 returns the union data inside the StatusReblog_Card as a StatusReblogCard1
func (t StatusReblog_Card) AsStatusReblogCard1() (StatusReblogCard1, error) {
	var body StatusReblogCard1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStatusReblogCard1 overwrites any union data inside the StatusReblog_Card as the provided StatusReblogCard1
func (t *StatusReblog_Card) FromStatusReblogCard1(v StatusReblogCard1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStatusReblogCard1 performs a merge with any union data inside the StatusReblog_Card, using the provided StatusReblogCard1
func (t *StatusReblog_Card) MergeStatusReblogCard1(v StatusReblogCard1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t StatusReblog_Card) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *StatusReblog_Card) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsPoll returns the union data inside the StatusReblog_Poll as a Poll
func (t StatusReblog_Poll) AsPoll() (Poll, error) {
	var body Poll
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPoll overwrites any union data inside the StatusReblog_Poll as the provided Poll
func (t *StatusReblog_Poll) FromPoll(v Poll) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePoll performs a merge with any union data inside the StatusReblog_Poll, using the provided Poll
func (t *StatusReblog_Poll) MergePoll(v Poll) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsStatusReblogPoll1 returns the union data inside the StatusReblog_Poll as a StatusReblogPoll1
func (t StatusReblog_Poll) AsStatusReblogPoll1() (StatusReblogPoll1, error) {
	var body StatusReblogPoll1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStatusReblogPoll1 overwrites any union data inside the StatusReblog_Poll as the provided StatusReblogPoll1
func (t *StatusReblog_Poll) FromStatusReblogPoll1(v StatusReblogPoll1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStatusReblogPoll1 performs a merge with any union data inside the StatusReblog_Poll, using the provided StatusReblogPoll1
func (t *StatusReblog_Poll) MergeStatusReblogPoll1(v StatusReblogPoll1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t StatusReblog_Poll) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *StatusReblog_Poll) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Verify account credentials
	// (GET /api/v1/accounts/verify_credentials)
	GetApiV1AccountsVerifyCredentials(ctx echo.Context) error
	// Get account
	// (GET /api/v1/accounts/{uid})
	GetApiV1AccountsUid(ctx echo.Context, uid string) error
	// Get account’s statuses
	// (GET /api/v1/accounts/{uid}/statuses)
	GetApiV1AccountsUidStatuses(ctx echo.Context, uid string, params GetApiV1AccountsUidStatusesParams) error
	// View public timeline
	// (GET /api/v1/timelines/public)
	GetApiV1TimelinesPublic(ctx echo.Context, params GetApiV1TimelinesPublicParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// GetApiV1AccountsVerifyCredentials converts echo context to params.
func (w *ServerInterfaceWrapper) GetApiV1AccountsVerifyCredentials(ctx echo.Context) error {
	var err error

	ctx.Set(NPubOrNSecScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetApiV1AccountsVerifyCredentials(ctx)
	return err
}

// GetApiV1AccountsUid converts echo context to params.
func (w *ServerInterfaceWrapper) GetApiV1AccountsUid(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "uid" -------------
	var uid string

	err = runtime.BindStyledParameterWithLocation("simple", false, "uid", runtime.ParamLocationPath, ctx.Param("uid"), &uid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter uid: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetApiV1AccountsUid(ctx, uid)
	return err
}

// GetApiV1AccountsUidStatuses converts echo context to params.
func (w *ServerInterfaceWrapper) GetApiV1AccountsUidStatuses(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "uid" -------------
	var uid string

	err = runtime.BindStyledParameterWithLocation("simple", false, "uid", runtime.ParamLocationPath, ctx.Param("uid"), &uid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter uid: %s", err))
	}

	ctx.Set(NPubOrNSecScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApiV1AccountsUidStatusesParams
	// ------------- Optional query parameter "max_id" -------------

	err = runtime.BindQueryParameter("form", true, false, "max_id", ctx.QueryParams(), &params.MaxId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max_id: %s", err))
	}

	// ------------- Optional query parameter "since_id" -------------

	err = runtime.BindQueryParameter("form", true, false, "since_id", ctx.QueryParams(), &params.SinceId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter since_id: %s", err))
	}

	// ------------- Optional query parameter "min_id" -------------

	err = runtime.BindQueryParameter("form", true, false, "min_id", ctx.QueryParams(), &params.MinId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min_id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "only_media" -------------

	err = runtime.BindQueryParameter("form", true, false, "only_media", ctx.QueryParams(), &params.OnlyMedia)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter only_media: %s", err))
	}

	// ------------- Optional query parameter "exclude_replies" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude_replies", ctx.QueryParams(), &params.ExcludeReplies)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude_replies: %s", err))
	}

	// ------------- Optional query parameter "exclude_reblogs" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude_reblogs", ctx.QueryParams(), &params.ExcludeReblogs)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude_reblogs: %s", err))
	}

	// ------------- Optional query parameter "pinned" -------------

	err = runtime.BindQueryParameter("form", true, false, "pinned", ctx.QueryParams(), &params.Pinned)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter pinned: %s", err))
	}

	// ------------- Optional query parameter "tagged" -------------

	err = runtime.BindQueryParameter("form", true, false, "tagged", ctx.QueryParams(), &params.Tagged)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tagged: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetApiV1AccountsUidStatuses(ctx, uid, params)
	return err
}

// GetApiV1TimelinesPublic converts echo context to params.
func (w *ServerInterfaceWrapper) GetApiV1TimelinesPublic(ctx echo.Context) error {
	var err error

	ctx.Set(NPubOrNSecScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApiV1TimelinesPublicParams
	// ------------- Optional query parameter "local" -------------

	err = runtime.BindQueryParameter("form", true, false, "local", ctx.QueryParams(), &params.Local)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter local: %s", err))
	}

	// ------------- Optional query parameter "remote" -------------

	err = runtime.BindQueryParameter("form", true, false, "remote", ctx.QueryParams(), &params.Remote)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter remote: %s", err))
	}

	// ------------- Optional query parameter "only_media" -------------

	err = runtime.BindQueryParameter("form", true, false, "only_media", ctx.QueryParams(), &params.OnlyMedia)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter only_media: %s", err))
	}

	// ------------- Optional query parameter "max_id" -------------

	err = runtime.BindQueryParameter("form", true, false, "max_id", ctx.QueryParams(), &params.MaxId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max_id: %s", err))
	}

	// ------------- Optional query parameter "since_id" -------------

	err = runtime.BindQueryParameter("form", true, false, "since_id", ctx.QueryParams(), &params.SinceId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter since_id: %s", err))
	}

	// ------------- Optional query parameter "min_id" -------------

	err = runtime.BindQueryParameter("form", true, false, "min_id", ctx.QueryParams(), &params.MinId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min_id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetApiV1TimelinesPublic(ctx, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/api/v1/accounts/verify_credentials", wrapper.GetApiV1AccountsVerifyCredentials)
	router.GET(baseURL+"/api/v1/accounts/:uid", wrapper.GetApiV1AccountsUid)
	router.GET(baseURL+"/api/v1/accounts/:uid/statuses", wrapper.GetApiV1AccountsUidStatuses)
	router.GET(baseURL+"/api/v1/timelines/public", wrapper.GetApiV1TimelinesPublic)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
